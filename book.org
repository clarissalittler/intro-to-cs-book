#+LATEX_CLASS: book
#+LATEX_HEADER: \usepackage{proof}
#+LATEX_HEADER: \newcommand{\key}[1]{\textcolor{blue}{#1}}
#+AUTHOR: Clarissa Littler
#+TITLE: Introduction to Computer Science in Javascript
#+EXCLUDE_TAGS: meta
#+OPTIONS: toc:nil

* Introduction
** The Goals of This Book
   The fundamental goal of this book is to teach the basic ideas of programming and computation in a way that's both mathematically rigorous and still understandable to anyone who's had even a single term of algebra. 

   My goal in /writing/ this book is to try and demystify the process of programming. I basically want to write the book I had wished I'd had more than a decade ago when I was first learning to write code. Back then, I was working on my master's degree in physics and I needed to modify some programs for a simulation we were running. I read some online tutorials for C++ and Fortran, the two languages we used, and managed to eventually lurch my way to my first working code. Even though I ended up writing working programs, I still didn't understand /why/ the lines of code needed to look the way they did or why all the previous attempts I'd muddled through /didn't/ work. I had no way of predicting what a program was going to do until I ran it.

   It wasn't until a number of years later, as I started teaching myself other programming languages such as Common Lisp and Haskell, that I began to understand the fundamentally mathematical nature of programs. I learned that programs /have/ rules and they're not (entirely) arbitrary. I learned that I could predict what a program was going to do even before I ran it. I figured out how to evaluate pieces of code with pen and paper before even typing anything. Finally, I discovered that not only are there rules behind every programming language, but there are in fact meta-principles that govern most programming languages and how to learn them. There are underlying principles behind /computation/ and different styles of programming languages merely take different perspectives on how to describe those underlying computations.

   To this end, I take a mostly neutral stance on choice of programming languages and styles of programming. I don't believe that there's a "best language" for everyone, but I do think any given person or team may find that a particular language is best for the way they think and the way they conceive of computation. 

   On the other hand, we have to pick a particular language in order to write this book and to that end I've chosen the Javascript programming language. Why JavaScript? Because at the end of the day JavaScript is a very flexible, popular, language that is able to adapt itself to many different styles of programming. It doesn't force you to write your code in /only one way/. 

Ultimately it is my hope that after reading this book it should be relatively simple task to learn any language you want and know how to write the programs you want to write in it.
** Outline of The Book
   Part 1 of the book proper is going to be centered on the basic built in operations and kinds of data that exist in Javascript and the /structure/ of programs themselves. We'll be covering
  + basic operations on numbers
  + how to makes choices
  + how to define functions
  + reading input into a program
  + printing output from a program
  + how to repeat actions
  + how to use objects to store data
  + how to encapsulate data using functions and scope

Part 2 of the book will be more advanced topics including:
  + advanced use of closures
  + prototypes, inheritance, and object oriented programming
  + the use of data structures such as dequeues, graphs, and heaps

Part 3 of the book will be a sequence of programming projects that will help connect all of the main topics together.
** Getting Started in Javascript
* The Basics of Programming
** What Computation Is
   Before we start explaining the details of Javascript we first need to give a basic explanation of what we /mean/ by computation. 

   Essentially, a /computation/ is a process that takes a finite number of steps to perform an action. In its most general form, a computation is allowed to be interactive, receiving input at a number of points and returning output. 

   Now, we mostly associate computations with /computers/ but a computer is to computation as a calculator is to arithmetic. It's convenient to use, but not strictly necessary. Consider how we add two numbers together. If we were to describe the finite /process/ of adding two generic numbers it might go something like "to add ~m~ and ~n~ we add 1 to ~n~ a total of ~m~ times". This gives us a procedure that describes what addition means, assuming that we know how to add 1 to a number. Similarly, we can describe multiplication as a finite process by appealing to addition "to multiply ~m~ and ~n~ we add ~n~ to ~n~ a total of ~m~ times".  So for example with this definition of multiplication we can describe 3*5 as 

#+BEGIN_LaTeX
  \begin{align*}
    3 * 5 &= 5 + 2*5 \\
          &= 10 + 1*5 \\
          &= 15 + 0*5 \\
          &= 15 \\
  \end{align*}
#+END_LaTeX
Now this might sound a little unnatural but if you squint at it it's basically just counting by fives, the way you learned how to do as a child. That's because counting by ~n~ is a /computation/ and takes a finite number of steps. 

Other things that count as computations would be
  + sorting your music collection alphabetically
  + keeping score in cribbage
  + balancing your checkbook
  + transcribing a conversation

If it's starting to sound like almost /everything/ counts as a computation, that's because most things are. There's even a hypothesis that every physical process in the universe is, on some level, a computable process. 

Even if that hypothesis isn't true, the purview of computation is still very large and covers a great many things. A good rule of thumb is that any process that can be described as using 
  + a finite number of rule
  + a finite amount of data
  + and a finite amount of time to finish succesfully
is probably computable. If you look at all the previous examples, they fit into those three criterion. 

What kinds of problems /aren't/ computable? One example would be "add up all the numbers in an infinite list and return their sum". It takes an infinite amount of time add up all the numbers in the infinite list, and unless all but a finite number of elements of the list are 0 then it will also take an infinite amount of /data/. Another would example would be creating a table that lists every digit of \pi. This would require an infinite amount of data, and so couldn't possibly be computable. The common theme of all the things that are /not/ computable is that they are /infinite/ in some way. A more pragmatic example actually is inspired by understanding computer programs themselves! It turns out that trying to determine, with perfect accuracy, whether or not a program has a virus is /not computable/, which means that there's no possible way to write a perfect anti-virus scanner.   

On a theoretical level, the fact that so many things are computable is the reason why computers have proven themselves to be so useful to us. 

That's a lot of description of what kinds of things /are/ computable, but what does it actually mean to describe a computation? The rule of thumb we've given is just an informal way to guess if something is computable. We don't know how to /define/ computations.

To define computations, we'll need some kind of formal language much like we had when learning algebra. The language of algebra gave us the ability to write things such as
#+BEGIN_LaTeX
  \begin{align*} 
    f(x) &:= 3*x \\
    g(x) &:= f(x) + 10 \\
    h(x,y) &:= x^2 + y^2 \\
  \end{align*}
#+END_LaTeX
and have these functions be well defined. We know how to apply these functions by /substituting/ in numbers for the variables in the equations as in the following examples.
#+BEGIN_LaTeX
  \begin{align*}
    f(3) &= 3*3 = 9 \\
    g(10) &= 3*10 + 10 = 40 \\
    h(3,4) &= 3^2 + 4^2 = 25 \\
  \end{align*}
#+END_LaTeX

In addition to the ability to functionally define equations, we also have, built-in, all the arithmetic operations such as +,*,-, and the exponential operations. At this point, we need to make a distinction between syntax and semantics. By syntax we mean the literal symbols themselves, as in 
#+BEGIN_LaTeX
  \begin{align*}
    3*4 + 10 \\
    x^2 + y \\
    f(10) \\
  \end{align*}
#+END_LaTeX
Now, if you look at those symbols you can probably guess what they /mean/ when interpreted as numbers but what's literally there are just symbols. + is just +, * is just *, etc. They don't have meaning until they've been /evaluated/. This meaning of the symbols, that assigns the meaning of /addition/ to the symbol +, multiplication to the symbol *, is the semantics of the formal language of algebra. Every formal language has both a /syntax/ and a /semantics/ and our general procedure from here on is to introduce pieces of syntax along with their semantics, so that you may in principle evaluate your programs by hand. 

While we can define many arithmetic functions using this equational algebra and while all of these arithmetic functions are computable [fn:: At least when restricted to a suitable subset of the real numbers], there's many things that this language of functions cannot define. For example, we can only define functions on numbers. We also cannot define functions that are fundamentally interactive, asking for input from some other source.

In order to define general computation, we need a language that is far more complex than just having equations and operations on numbers. Unsurprisingly, this will be our /programming/ language. 
*** Turing's Conception of Computation
    Alan Turing is, arguably, the first person who came up with an easy to understand model of computation. In Turing's day, "computer" was a job title rather than a device. Computers worked out computations, by hand, such as firing solutions for the military. Turing was inspired by the way that these computers worked, where they had a finite but /arbitrary/ amount of scratch paper for their calculations and were able to stop their computation at any point, take a break, and come back to their work later. Abstracting away from these observations, Turing came up with the notion of a Turing machine. A Turing machine is a device that has an infinite roll of tape that it can write on, divided into individual cells where a single character can be written, and a movable head that can move around the tape. 

    A given Turing machine is hard wired to be able to read a single character off the tape and then decide to 
   + terminate succesfully
   + terminate unsuccesfully
   + write a new character into that cell
   + move the head left or right on the tape
   + enter one of a finite number of pre-defined configurations for deciding the next action
The way a Turing machine operates is that its input is written onto the tape in advance, then it continues to process the input according to its hard-wiring until it either terminates succesfully, with the output written on the tape, or terminates unsuccessfully because the input was ill-formed. 

Given our informal definition of computation above, we can see that this matches what something /computable/ should be. There's a finite amount of data that's used on the tape at any finite time. There's a finite number of rules in that there's only a finite number of things the Turing machine can do in any configuration. Also, if the Turing machine finishes successfully it must only take a finite number of operations.

Turing's machines were not the first or only way to conceptualize computation, there were also the partially-recursive functions and the lambda calculus, but these were very abstract tools for mathematicians that, while they do describe all computations, don't characterize an intuition for what computable things are "like". Turing machines on the other hand give us this intuitive feel for the finite nature of something that is computable. 

** What Programs Are
   We've tried to define what computation is, on some level, but we haven't answered the obvious question on the nature of /programs/. 

   A program is a piece of text in a formal language that defines a computation. I think a good analogy is to consider the computation itself as the process of cooking a meal. A program, then, is the written recipe that describes how to perform this process correctly. You are playing the role of the interpreter, in this case, reading the instructions and figuring out what they mean and carrying them out. 

   There's a major difference, though, between a recipe or directions to a friend's house and a program. The difference is that /you/ are much, much smarter than a computer. A recipe doesn't have to explain every tiny detail of how you boil water, turn on a stove, pulling ingredients out of the fridge, or what "to taste" means for a seasoning. On the other hand, /you/ have to describe in painful detail how to do almost everything for a computer. A good programming language will have a wide variety of built-in kinds of data and operations whose meaning the programming language designer has already defined for you. They work as building blocks that can fit together to make whatever you want. The process of building can still be very, very complicated and tedious and difficult.

   Programming requires a level of precision in thinking and clarity in writing that normal life doesn't require, because in general we're communicating with each other and it's usually quite clear to someone else what you mean even if you misspoke. Computers can't figure those things out. If you misspeak when programming, the computer will do the wrong thing. That is what we call a bug in a program, and they're very easy to cause. If anything, I want to impress on you that programming can be difficult at first simply because for many people it's not a natural way to think. So don't be discouraged if it takes some time to /think/ like a programmer. It wasn't something that came easily to me at first, since I came from mostly a pure mathematics background, but over the years I've grown very confident in my abilities. 
*** A Mathematical Aside On Programs and Infinity
    This is an optional section that is not necessary to understand the text of this book, but presents an argument that I think is fairly useful for understanding the limitations of what a computer can do. 

    We need to introduce a few mathematical constructs that may be unfamiliar. The first of these is a "set". A set in mathematics is an abstract collection of things. Examples of well-defined sets in mathematics are
    + the set of all real numbers
    + the set of all grammatically correct sentences in English
    + the set of chickens named Belina
    + the set of recipes that I've used in the past year
Some of these sets are /finite/, by which we mean we can count them in a finite amount of time. The set of chickens named Belina and the set of recipes I've used are both finite. Some of these sets are /infinite/, such as the set of all grammatically correct sentences and the set of all numbers. 

There's a distinction though between the set of all sentences and the set of all numbers. The set of all sentences is /countable/ in the sense that we can count all of them if we give ourselves an /infinite/ amount of time. On the other hand, the set of all real numbers is /so large/ that even with an infinite amount of time you couldn't possibly count all of them. In fact, you can't even count all of the real numbers between 0 and 1! This means that the set of all real numbers is /uncountable/. 

The most important countable set is the set of /natural numbers/, which are formally defined as being either 0 or one plus a natural number. So the natural numbers consist of 0,1,2, etc. The natural numbers /are/ the counting numbers.

Another important uncountable set is the set of all functions that take in a natural numbewr and give you back a natural number. We won't prove that here, but rather just assume it as a fact.

A rather interesting set is the /set of all programs/ for a given programming language. Is this set countable or uncountable? A program is a finite piece of text with a finite set of symbols. Again, we'll skip the proof but it turns out to be true that if you're dealing with /finite/ texts over a /finite/ alphabet then there's at most a /countable/ number of texts. A countable number of texts means a countable number of /programs/. A countable number of programs can't possibly encode an /uncountable/ number of functions.

This means that of all of the mathematically definable functions from the natural numbers to the natural numbers, a programming language can only describe at most a countable fraction of these functions. 

What does this mean for computer science and how it relates to programming? It means that there's an absurdly infinite number of things mathematics that cannot be described as computations. So even though a lot of the processes that we deal with every day make sense as computations, most of the things mathematicians do every day are much harder to describe computably. 

The essential thing to take from this digression is that there's a theoretical /reason/ why writing the right program to solve a problem can be very difficult. The most obvious way to try and solve a problem might not even be computable.
** Informal Descriptions and Algorithms
   Programming-in-itself can be an enjoyable exercise, but we write code in order to solve a problem. The first part of solving any problem is going to be describe our solution informally, in words, rather than jumping straight into code.

   For example, if our problem is how to put a bookcase into alphabetical order an informal description might sound something like 
#+BEGIN_QUOTE
First, remove all the books from the book shelf and put them in piles corresponding to the first letter of the last name of the author. Sort each pile individually into alphabetical order, then put the piles back on the bookshelf in the proper order.
#+END_QUOTE
Now, this description leaves out some details but it's a rough description of what to do and how to do it, enough so that later when we're sorting data in a program we'll /implement/ this informal description fairly directly.

There's a couple of reasons why it's best to start with describing the problem in words. First, to clarify to yourself how you want to solve the problem. It's easy to get lost in the woods when you're working on a large program if you're figuring out the details as you go. If you have the big picture in front of you and you've already thought the solution through, you're far less likely to go back to the drawing board in the middle of coding. 

Second, an informal description is more portable. You, or more likely someone else, can implement your solution in a different programming language. Even though programming languages can look very different from each other they all have their own way of describing how to perform computation. 

(insert diagram of one to many to one relationship here)

These informal descriptions of solutions are generally called "algorithms" and the ability to clearly write down an algorithm in an understandable way is a valued skill in both academic and commercial programming. In our descriptions of algorithms we'll be introducing key words formatting like \key{this}. These \key{key} words are going to map directly onto programming concepts. 

** A First Problem				:project:informaldescription:
   The very first task we're going try to solve is to ask the user for the title of a book and printing it back out in proper title case. 

   Our informal description of our solution is 
#+BEGIN_QUOTE
First we \key{prompt} the user for the name of a book. \key{If} they didn't enter a title, \key{then} we should \key{print} "goodbye" and end the program, \key{otherwise} we should convert the book into title case. To convert the book into title case, we need to check each letter and, \key{if} it starts a word that isn't article, preposition, or conjunction \key{then} we capitalize it. \key{When} we reach the end of the title we \key{print} it out and say "goodbye" to the user.
#+END_QUOTE

The next several sections are going to outline all the syntax we need in order to implement this algorithm. We'll introduce a number of smaller problems to illustrate how each piece of syntax and we'll tie all of it together by showing how we translate the above description into an actual program.
** First Steps
 The /very/ first piece of syntax we're going to introduce in Javascript is how to print out values within a program. 

 Write the following lines of code in a file called ~FirstSteps.js~.
 #+BEGIN_SRC js :exports code :results output :tangle FirstSteps.js
   console.log(10);
   console.log(100);
   console.log(300);
 #+END_SRC

 #+RESULTS:
 : 10
 : 100
 : 300

If you run this file using the following command you should see the output indicated.
#+BEGIN_SRC sh :exports both :results output
  node FirstSteps.js
#+END_SRC

#+RESULTS:
: 10
: 100
: 300

We need to discuss what's happened here. First off, we've introduced the syntax ~console.log(v)~, whose semantics is to print out to the console the value of its argument, this means that it prints out the result of Javascript evaluating ~v~ and not just the literal syntax of ~v~ as we'll see shortly. This will be very useful for us in testing out our programs and checking that we understand the semantics of our constructs.

The second piece of syntax we've implicitly introduced is the /semi-colon/ and the /line break/. Javascript separates its syntax into /statements/ and /expressions/. We'll make more clear what the distinction between these two, but at first let's just say that statements are things that are separated by lines and expressions are things that can be fed as arguments. So, for example, ~10~ and ~console.log(10)~ are expressions but ~console.log(10);~ is a statement. For readability it's best to put statements on new lines, even though technically you could have written the above code as 

#+BEGIN_SRC js :exports code :results output 
  console.log(10);console.log(100);console.log(300);
#+END_SRC

but this isn't recommended as it makes code much harder to read.[fn:4]

Some other languages that use semicolons are Java, C, C++, C#, and PHP. The use of semicolons is one of those historic conventions that's good for the person writing the implementation of the programming language, but less so for the programmers who need to work in that language. Going back to our analogy about recipes, think of an expression as a thing like "a cup of flour" or "six onions" but a /statement/ is a step in the recipe such as "sautee six onions until soft". So in the example above each line that has ~console.log(v);~ in it is a separate statement that is executed in order, just like you'd execute the steps of a recipe in order. 

Now that we have a way to print out values and are starting to understand the difference between expressions and statements, we can start introducing operations on numbers as a first step. We have in JavaScript all the basic operations you're familiar with, including +,*, and -. We can see how they work in the following code, which you can copy into a file called ArithmeticExpressions.js

#+BEGIN_SRC js :exports code :results output  :tangle ArithmeticExpressions.js
  console.log(10 + 10);
  console.log(10 * 10);
  console.log(10 - 10);
  console.log(10 / 10);
#+END_SRC

#+RESULTS:
: 20
: 100
: 0
: 1

If you run this code with the following snippet then you should see the same results as below.

#+BEGIN_SRC sh :exports both :results output
  node ArithmeticExpressions.js
#+END_SRC

#+RESULTS:
: 20
: 100
: 0
: 1

It's important to note that the number that's printed out is the /result/ of the expression that's passed into the ~console.log~. 
*** Evaluating Code By Hand
    One of the themes of this book is going to be how to take a pen and paper and evaluate your code. This might seem like an odd skill to learn, but it's useful for getting rid of some of the "magic" feeling that comes with writing code for the first time. If you're not sure how a piece of code works, it's really helpful to be able to sit down and go through it step-by-step for yourself. 

So far, we've seen three pieces of syntax: 
    1. the ability to print using ~console.log~
    2. numbers represented using the normal decimal representation
    3. basic arithmetic operations on numbers
and two classes of syntax
    1. expressions
    2. statements

First, as we've aluded there's a notion of *values*. What makes an expression an expression is that it returns a *value* when evaluated. Statements, on the other hand, are useful for their control flow. When we coerce an expression into being a statement via ~expression;~ what we are doing is inherently throwing away the value returned by the expression. This is useful for things like ~console.log~ where we're not actually returning anything particularly useful and just using the /side effects/ of the expression. Side effects are all the ways an expression can affect the world other than through the value they return. So far the only side-effect we've seen is the ability to print output. We'll point out other side-effects as we're introduced to them.

Now, we take the pieces of syntax we've seen so far in order:
  1. ~console.log(e)~ is evaluated by first evaluating ~e~ until it yields a value ~v~ and then writing that value down under a column labeled "Output" on your paper
  2. numbers are evaluated simply: a number ~n~ written in decimal notation evaluates to itself, i.e. numbers are already values
  3. basic arithmetic operations are evaluated as the normal arithmetic rules you've learned, i.e. ~+~ is addition, ~-~ is substraction etc.
** Basic Types
We've informally used numbers and arithmetic in the previous section, but now we need to describe what /kinds/ of data that we can use in JavaScript. In this and the next several sections we'll be covering the fundamental constructs of JavaScript, how they're used, and ways to understand them. In each section we'll be explaining also how to evaluate the code by hand and providing exercises where can do just that. It's completely valid to simply skim this section and jump into the projects, going back and reading about the constructs you need as you go. 

We'll start with the simplest of all kinds of data. 

*** Strings
     Even though it's fairly transparent, words themselves are a kind of data we constantly deal with: our texts, our emails, our social media posts are all text-as-data that our computers interact with.
     
     Given that our programs are also /text/, we need some way to distinguish between text-as-data and text-as-instructions for the computer. Text-as-data are called /strings/. We denote strings with quotation marks, either "like this" or 'possibly like this'. This mimics what we do in English all the time: there's a difference between this sentence and "this sentence". It's like the old playground joke "Say 'Mississippi five times fast'" to which you're supposed to respond "Mississippi five times fast". In fact, Javascript allows us to do exactly that. If we want to include quotation marks within a string we can either "do something 'like this'" or 'maybe something "like this"'.

     We can 
**** Evaluation
     Strings, like all primitive data evaluate to themselves. You can test this yourself by starting up the Node command line and typing a string, like in the following example
     #+BEGIN_EXAMPLE
     clarissa@ramiel ~ $ node
     > "this is a string"
     'this is a string'
     > 'this is also a string'
     'this is also a string'
     > 'this is a string "with" quotations'
     'this is a string "with" quotations'
     > 
     #+END_EXAMPLE

**** Exercises
     
*** Numbers
     We see numbers all the time, so they are probably the most familiar datatype you'll see in any programming language. 

     In JavaScript, numbers are written exactly like they normally are in mathematics: =1=, =10=, =-5000=, =3.14= etc. If you have any experience with other programming languages such as C or Java, it's notable that there's only /one/ form of number in JavaScript and not separate kinds of numbers for whole numbers or fractional numbers. 

     You can perform most of the operations on numbers you may have seen: =+=, =-=, =*=, and =/=. These all behave like you'd expect =+= is addition, =-= is subtraction, =*= is multiplication, and =/= is division. There's even the =%= operator which you may not have seen before. We call =%= the /remainder/ operation which, for =a%b=, returns the number left after you subtract =b= from =a= as many times as you can without going negative. Examples are in order. For =5 % 2= you can subtract =2= /twice/ from =5= which leaves =1= as a remainder. Similarly for =14 % 4= then =4= only goes into =14= three times, leaving =2= as a remainder. 

     There are, however, two special kinds of numbers in JavaScript: =Infinity= and =NaN=. Why does JavaScript have them though? Start running node or open the console in your browser and type the following expression: =1 / 0=.

     Most programming languages will throw an error or even *crash* when you divide by 0, but in JavaScript you instead get a result of =Infinity=. You can even use =Infinity= like it /was/ a number. Try typing the following expressions in your console:

     + =Infinity * Infinity=
     + =Infinity + 0=
     + =Infinity - Infinity=

What happened with that last one? You got the other odd number =NaN= which stands for "not a number". =NaN= is used in JavaScript to mean that the result was technically a /number/ but it doesn't have a well-defined value. Doing something like =Infinity - Infinity= doesn't have a well defined mathematical value. Neither does =Infinity * 0= or =Infinity / Infinity=. 

=NaN= shows up in more cases than just doing math with =Infinity=, though. =NaN= is returned whenever you are attempting arithmetic operations on something that doesn't make sense like, say, multiplying a string by a number. For example, try typing =3 * "3"= into the console. Once you have =NaN= there's no way to get back to the world of simple numbers. You can try something like =NaN * 0= or =NaN + Infinity= but the answer will *always* be =NaN=.

Finally, all arithmetic operations work by the normal presedence rules: expressions in parentheses are evaluated before multiplications which are evaluated before division which are evaluated before remainders which are evaluated before addition which are evaluated before subtraction.

A short visual way to look at it is =() > * > / > % > + > -=. So, for example, if you see the JavaScript expression =10 * 11 % 10= will this evaluate like =(10 * 11) % 10=, which is equal to 0, or like =10 * (11 % 10)= which is equal to 1? Since multiplication beats calculating the remainder, then this means we should first turn =10 * 11 % 10= into =110 % 10= and then finish the remainder, leaving us with =0=. If we're dealing with multiple expressions, such as =10 / 3 / 2= the expressions are evaluated in pieces from left-to-right: ~10 / 3 / 2 = 3.3333333 / 2 = 1.6666667~

**** Exercises
***** Exercise 1
    Look at the following arithmetic expressions and calculate the result without typing them into the console, then check your answers afterward:

    1. =10 / 3 - 3=
    2. =10 / (3 - 3)=
    3. =5 % 4 % 3=
    4. =1 / 0 / 0=
    5. =Infinity + NaN=
***** Exercise 2
     Try to imagine three different situations where you might encounter =Infinity= or =NaN= and they should be handled if detected.
*** Variables
    The next important piece we need to learn is how to store the results of our operations. We store data in something called /variables/. 
**** An aside on algebra
     If you've ever had an algebra course, you might be familiar with variables in /that/ context. Variables in mathematics are things like what we see in the defintions of functions, e.g. $f(x) = x + 10$, or when solving equations such as $x^2 - 2x + 1 = 0$. In both of these cases they're "variable" in the sense that you can /vary/ what you feed to the function $f(x)$ or what value you check to solve the equation $x^2 - x2 + 1 = 0$.

     This is like the variables-as-names use, but not at all like variables-as-containers.

     Variables-as-containers is a uniquely computer science use of the term. Some computer scientists argue that /reference/ is the right word for variables-as-containers and that we should treat these two concepts as different in our programming languages, but very few languages actually do this. 

     Confusing or not, references will probably always be called variables.
**** Variables-as-placeholders
    Imagine you're telling a story but you want a placeholder for the actual name of the person in the story. You might say something like "So a friend of mine, call her Sandra, used to be a lion groomer"
**** Variables-as-containers
     Variables can be used to hold values that are allowed to change later 
**** Syntax
     Explain both variable creation and assignment
**** Evaluation
     Using the name of a variable means three separate things in the three contexts they can show up
     1. creation
     2. assignment
     3. use
 the first two are pretty similar, and the typical form of =var v = val= is, in some sense, both of those first two at once. 

     The important detail is that there's if the variable is on the left hand side of an equals sign then it's referring to the container, but if the variable name is on the right hand side of an equals or in any other context but variable creation it means the /value/ that's stored in the container. I think that might confuse people when they first see it.

     Need to explain by-hand evaluation rules, where you right down on a piece of paper all the variables and make a little table of their values
**** Undefined
     We've skirted around one bit of weirdness until now: what happens if you attempt to use a variable that you haven't assigned a value to?

     Let's try this quickly and type the following lines in your console:

#+BEGIN_EXAMPLE
var x
x
#+END_EXAMPLE

     Surprisingly, there /is/ a value in the variable, =undefined=: a very special value that represents "there's no value here".

     =undefined= is like a number or string in that it /evaluates to itself/ and has no other special rules.
**** Exercises
***** Exercise 1
      Explain how variables work in your own words and your own metaphors. Do you think "variable" is a good name for this concept? If you could choose any other word for it, what would it be?
***** Exercise 2
     After the following 
     Short exercises showing that variables can be assigned to each other and quizzing on what the final value is to make sure that the way referencing works is properly understood
*** Booleans
    Until now, all we've seen are operations akin to what you'd see on a calculator. Whether strings or numbers, we're merely performing simple operations on data and returning the result: adding numbers, concatenating strings. 

    Real programs do much more complicated things that involve choices or repetition. Think about logging into a computer and having it check your password. This involves making a comparison, is the password entered the same as the password expected, and then making a /decision/ about whether to let you use the computer. 

    The important pieces there are that the program needs to determine whether something is /true/ and then do one thing if it's true and another thing if it's not.

    To do these things we need to introduce the concept of /booleans/. There are *two* boolean values: =true= and =false=. We also have comparison operators that test for things such as "is this number bigger than that number" or "are these two things equal". 

    Below we have our table of boolean operations
    (insert table here)

    With these very /simple/ operations in hand, how do we make /decisions/? The most basic way to make a choice in programming is to use the /if statement/.

    The most basic if-statements in JavaScript have the following shape

   (* we should probably use some kind of fancy verbatim environment for these pseudo-code segments *)
    #+BEGIN_SRC js :exports code 
      if (condition) {
         /statements/
      }
      else {
         /statements/
      }
    #+END_SRC

    As an example, we could have something like 
    #+BEGIN_SRC js :exports code
      if (10 > 3) {
          console.log("ten is greater than three");
      }
      else {
          console.log("oh dear ten is smaller than three?!");
      }
    #+END_SRC

Here you have a condition that should evaluate to either =true= or =false= and if it is =true= then the first set of instructions, and only the first set of instructions, will be executed

**** Real life examples and analogues
     Conditions and questions: is it raining? Am I taller than her? Am I enjoying this book? Yes or no => true/false
**** Evaluation
     true and false evaluate to themselves
**** Operations
     logical operations as well as equality and comparison operators
     explain only the "triple equals" at first, possibly including a footnote on the "double equals" instead
***** Shortcircuiting
      Shortcircuited operations
**** Truthy and Falsy
     Discuss what counts as "true" and what counts as "false" to JavaScript
**** Exercises
     (include exercises on diagramming programs based on choice)
***** Evaluating by hand
      Evaluate the following programs by pen and paper the way we've described

      #+BEGIN_SRC js :exports code
        if (10 + 10 > 19) {

        }
        else if (
      #+END_SRC
** Control Flow
   (We need to explain how control flow constructs are the "verbs" of a programming language, they describe what to do with the data. There's three classes of control flow for the purposes of teaching. 

   1. Branching: choosing between actions 
   2. Iteration: doing things repeatedly
   3. Calling functions: switching context to a different piece of code and then coming back to where you were

   Now I was a little wary about calling functions a control flow construct, but they really are because they're changing the execution context and running code that isn't the next literal line in the textual representation. 

   I might end up changing my mind a bit on this at some point, but I think it's a reasonable approximation
)
*** If-statements
**** Real life examples and analogues
     If statements are represented by our notion of decisions in our directions. The keywords to look out for are /if/ or /when/. Whenever your informal description includes /if/ or /when/ or /then/ or /else/, you're going to have some kind of if-statement in your code. 
**** Syntax
     The first form of /if-statement/ we'll see has three parts to it: a /condition/ that you're testing
**** Evaluation
     if-statements /first/ evaluate their condition, /then/ run the appropriate block of code (if any). This is where truthy and falsy data is important. 
*** Iteration
    The idea of doing things multiple times is something we're generally comfortable with. There's two basic kinds of iteration: doing something a set number of times or for each item in a collection  
**** for-statements
***** Real life examples and analogues
      In real life we do things like
      + dust /each/ shelf on the bookcase
      + chop /three/ onions
      + go to each class
***** Syntax
***** Evaluation
**** while-statements
***** Real life examples and analogues
***** Syntax
***** Evaluation
*** Functions and Function Calls
    
**** Declaring functions
**** Naming functions
**** Calling functions
**** Function scope
** Project 1						 :project:assignment:
   Now we can actually turn our attention to our first problem. Let's start by restating the description in English

#+BEGIN_QUOTE
First we prompt the user for the name of a book. If they didn't enter a title, then we should print "goodbye" and end the program, otherwise we should convert the book into title case. To convert the book into title case, we need to check each letter and, if it starts a word that isn't article, preposition, or conjunction then we capitalize it. When we reach the end of the title we print it out and say "goodbye" to the user.
#+END_QUOTE

  and now we implement this in code.

  First, we need look at how to /ask/ for input which is the only piece we haven't covered until now. For now, we're going to piggy back on the functionality of JavaScript in the browser and say 
** Libraries   
*** What are libraries?
    To this point in the book, you've been writing code /from scratch/. You've been starting with basic JavaScript and writing everything you need. This works for small programs, but imagine if you want to make an entire game in the browser, or code a complicated website that handles shopping online, or visualize data as pretty charts and graphs. Other programmers have already solved many of these difficult problems. 

    Other programmers have already figured out how to handle the physics of liquids moving in a video game, or how to securely encrypt data to keep credit card numbers safe in a transaction, or how to render a pie chart in the browser. The details of how to do these tasks are probably not important to you and, in the case of things like cryptography so hard to get right with such a high cost for a mistake, that you ideally want to rely on someone else who's put in the hard work to *get it right*. 

    Thankfully, essentially every programming language has /some way/ to include code from different files. We call these /libraries/. [fn:2] 
*** Libraries in JavaScript: script tags
*** Libraries in JavaScript: node and =require=
** Project 2
   In this project we'll be writing a program that simulates throwing a ball and plots out the position of the ball over time. We'll be making use of the =flotr2= library in order to make these relatively simple plots [fn:3].

   First, let's give a description in /words/ of what we want our program to do.
  (this description isn't information rich enough)
   #+BEGIN_QUOTE
   The program should \key{prompt} for the angle (in degrees), the initial speed of the ball (in meters per second), the time step (in seconds) for the simulation, and the number of points to calculate.

   The program will then calculate the position at the ball the required \key{number of times} and produce a line graph of the ball's trajectory.
   #+END_QUOTE

** Project 2 Redux   
** Objects
*** Objects-as-Containers
    Objects are directories, telephone books, dictionaries. They map names to items. They're like a collection of containers all labled with a name. Well how's that better than just using variables, a student might ask? The same way, if you're moving to a new home, you wouldn't just keep all your possessions loose and unorganized, an object is a way to organize the data in a way that can be moved around and transported.

    The basic syntax of making objects involves wrapping up pairs of "properties" and "values" between curly braces. Like the following ={age : 10, name : "Chicken", occupation : "Clucking"}=. 

    Now, what happens if we want to look information up in an object, retrieving the corresponding value by handing it the key? You can follow along in the following code snippet:
    #+BEGIN_SRC js :exports code
      var chicken = {age : 10, name : "Chicken", occupation : "Clucking"};

      console.log(chicken.age);
      console.log(chicken.name);
      console.log(chicken.occupation);
      console.log(chicken.homeOwnership);
    #+END_SRC

    #+RESULTS:
    : 10
    : Chicken
    : Clucking
    : undefined
    : undefined

    Much like with arrays, there's symmetry between how we /select/ elements and how we /set/ elements. You'll notice that our poor chicken doesn't have a home. We can easily give this chicken a home by typing the following into the console: =chicken.homeOwnership = true;= Now if you try typing =chicken.homeOwnership= you should see that this property is now set to =true=. 

*** Evaluating objects by hand
*** Methods
    Since functions are just a different kind of data in JavaScript, you can have object properties that have functions as values. For example, let's say we go with the most cliche of examples [fn:5] and represents /squares/ as objects. We'll want the square object to hold its side length and have functions that will return its area and circumference, as in the following code snippet.

#+BEGIN_SRC js :exports code
  var square = {side : 10,
		circum : function () {
		    return 4 * square.side;
		},
		area : function () {
		    return square.side * square.side;
		}};

  console.log(square.circum());
  console.log(square.area());
#+END_SRC

#+RESULTS:
: 40
: 100
: undefined

If you run this code you'll see that, indeed, the functions =square.circum= and =square.area= correctly output the circumference and area of the square respectively.

*** Constructors and this
   Imagine that you want to create the same /kind/ of object again and again, for example you have a social media program that needs to keep track of people's accounts. 
   
   You can make a single account like this
#+BEGIN_SRC js :exports code
  var person = {name : "Samael", screenname : "RadicalPoison", numberOfPosts : 300};
#+END_SRC
  but then you'd need to keep making individual accounts with this literal syntax every single time. That's pretty inconvenient, though. It'd be nice if we could make a function that constructs accounts from the necessary data.

We can do that like
#+BEGIN_SRC js :exports code 
  function Person(name,screenname){
      return {name : name, screenname : screenname, numberOfPosts : 0};
  }
#+END_SRC
and we can call this function whenever we want to make new objects to represent people. 

This very simple method starts to fall down, though, when we want to include methods. Let's go back to our example of the /square/. If we just straightforwardly translated our code from above it would look vaguely like:

#+BEGIN_SRC js :exports code
  function Square (side) {
      return {side : side,
	      circum : function () {
		  return 4 * ???.side;
	      },
	      area : function () {
		  return ???.side * ???.side;
	      }
	     }
  }
#+END_SRC   
 
but wait, what do we put in place of the =???=? Before we used =square= because that was the name of the square we were making. We don't have a concrete square to reference here! We're making a machine to make squares and trying to include, in the machine, a way for functions to reference the properties of a still hypothetical object.

This would be like trying to write civil rights law by naming, in advance, all the people it would apply to before they're ever born. 

Clearly, some other feature is needed and JavaScript has =this=. Literally, the key is the word =this=. The =this= keyword is a very special one in JavaScript that, in the context of methods of an object, is allowed to refer to the object executing the method in the first place. So fixing the above example we get

#+BEGIN_SRC js :exports code
  function Square (side) {
      return {side : side,
	      circum : function () {
		  return 4 * this.side;
	      },
	      area : function () {
		  return this.side * this.side;
	      }
	     }
  }

  square1 = Square(10);

  console.log(square1.area());
#+END_SRC

#+RESULTS:
: 100
: undefined

This is great! With functions and =this= we're able to make little factories that make new objects.


*** Prototypes and inheritance
    It's almost impossibly to spend any amount of time learning to code without coming across the term /object-oriented programming/. Object oriented programming is, in short, about using objects as the primary metaphor for organizing your code. 

*** Classes
    
**** Faking classes with prototyping

**** ES6 classes
** Closures
   Another deceptively powerful technique in programming is the /closure/.

   First, let's review how scope works with functions. Each function has its own scope, its own set of variables. These variables are searched from the inside out, with the most recently created scope being checked first. 

   The variables in these inner scopes work just like any other variables: they can be changed and referenced by any expression or function that can /see/ them.

   Let's consider the following code:

#+BEGIN_SRC js :exports code
  function outerFunction () {
      var a = 0;
      function innerFunction() {
	  a = a + 1;
      }
      innerFunction();
      innerFunction();
      console.log(a);
  }

  outerFunction();
#+END_SRC

#+RESULTS:
: 2
: undefined

This simple program defines a function called =outerFunction= that declares a variable called =a= and an "inner" function that increments the variable =a=. =outerFunction= then calls =innerFunction= twice and prints out the resulting value of =a=, which should be =2=. If you run this code on computer or paper you can confirm this is true.

What if we changed this function slightly, though, to the following example that is functionally similar:

#+BEGIN_SRC js :exports code
  function outerFunction() {
      var a = 0;
      function innerFunction() {
	  a = a + 1;
	  console.log(a);
      }
      return innerFunction;
  }

  fun = outerFunction();

  fun();
  fun();
#+END_SRC

#+RESULTS:
: 1
: 2
: undefined

Here, rather than calling =innerFunction= from within =outerFunction= we /return/ =innerFunction=. Whenever =innerFunction= is called, where does it look to get the value of the variable =a=? If you try this by hand you'll see that even though =innerFunction= is being called /outside/ the =outerFunction= it still looks at the =a= declared inside of it. 

This might just seem like a weird trick, but it's actually the key to some pretty neat programming tricks.

We can use closures to control /how/ data is seen, stored, and controlled. 
*** Closures can mimic objects
    Even if we didn't /have/ objects in JavaScript, we could mimic them with closures alone
*** Closures provide privacy
    One thing closures can do is create truly "private" data that can't be accessed by any means other than the interface the closure function provides. Imagine the following program, where you want some data to be accessible in an object but you want /some/ to be unchangeable, like a special user ID. This example will actually be a /closure/ that's a function that makes new objects.

#+BEGIN_SRC js :exports code
  function makePersonMaker() {
      var id = 0;
      return function (name) {
	  var myId = id;
	  var myName = name;
	  id = id + 1;
	  this.getId = function () {return myId}
	  this.name = function () {return myName}
	  this.sayHi = function () {
	      console.log("Hi there! I'm " + myName + " and my ID is: " + myId);
	  }
      }
  }

  var Person = makePersonMaker();
  var OtherPeople = makePersonMaker();

  var person1 = new Person("Mikey");
  var person2 = new Person("Annalise");
  var otherperson = new OtherPeople("Timulty");

  person1.sayHi();
  person2.sayHi();
  otherperson.sayHi();
#+END_SRC

#+RESULTS:
: Hi there! I'm Mikey and my ID is: 0
: Hi there! I'm Annalise and my ID is: 1
: Hi there! I'm Timulty and my ID is: 0
: undefined

Note that we actually have two layers of closures to make everything work the way we want. First, we are making our constructor function as a closure /around/ the =id=. We do this so we can have a separate =id= counter for each constructor we make with the =makePersonMaker= function. This allows for Timulty to be isssued an ID that's unconnected to the IDs either Mikey or Annalise. Second, the actual /object/ created when you say =new Person("Mikey")= has methods =getId=, =name=, and =sayHi= that are all /closures/ over the variables =myId= and =myName= in the constructor. This makes Mikey's name and ID private to only Mikey. They can't be changed by anyone else. That's what we mean by "privacy" in programming. 

Now, what if you are *really* sure that you're not ever going to need to different tracks of people in your program? Then you can employ a little JavaScript /idiom/ that you might sometimes see called an "immediately invoked function expression" or IIFE (iffy). Whether or not you think it deserves it's own special name, the concept is fairly simple: write your code as an *anonymous* function that you then immediately call. Turning our code above into an IIFE would look like

#+BEGIN_SRC js :exports code
  var Person = (function () {
      var id = 0;
      return function (name) {
	  var myId = id;
	  var myName = name;
	  id = id + 1;
	  this.getId = function () {return myId}
	  this.name = function () {return myName}
	  this.sayHi = function () {
	      console.log("Hi there! I'm " + myName + " and my ID is: " + myId);
	  }
      }
  })();

  var person1 = new Person("Mikey");
  var person2 = new Person("Annalise");

  person1.sayHi();
  person2.sayHi();
#+END_SRC

#+RESULTS:
: Hi there! I'm Mikey and my ID is: 0
: Hi there! I'm Annalise and my ID is: 1
: undefined

We still get the same privacy as before, but without the ability to create separate Person constructors that are disentangled from each other. 

*** Closures can mimick modules
** Project: Processing file formats
** ADTs
*** Importance of Abstraction
*** Lists
    (So obviously lists can just be arrays in JavaScript, but we can analyze the difference in efficiency between using arrays and using a true linked list implementation that uses objects to hold a value and a pointer to the next object.

    We'll be explaining the /interface/ of a list and then we'll talk about the ways to actually implement these interfaces as /arrays/, as /singly linked lists/, and as /doubly linked lists/ and we'll explain the pros and cons of each as well as having programming projects for each of these.

    One thing I want to do in this and the subsequent sections is going to involve showing how you can use prototypes in order to organize this code since I don't think there's a lot of good examples of prototypes that aren't just being shoved into class-forms )
*** Stacks
    Another abstract data type that's both simple and /useful/ is the *stack*. The mental image of a stack is like a stack of handouts or plates or napkins. Each item is data in the stack but you have to pull them off from the top before you can get to the bottom. [fn:6]

    This stack has two basic operations, =push= and =pop=. You can =push= new data down on top of the stack and =pop= it back off the stack. For convenience, we also have the ability to ask the stack how many elements it has inside it. 

    We have several equations we can test our data against: namely that ~x===s.push(x).pop()~ and (TODO)

    There are a couple of ways we'll implement this: the first is going to involve using an array to store the elements. The second involves a linked list like we saw above in the list ADT.

**** Array implementation
**** Linked list implementation
     First we revist the /linked list/ objects
     
     #+BEGIN_SRC js :exports code
       function Node (x) {
           this.data = x;
           this.next = null;
           this.length = function () {
     	  if (this.next) {
     	      return (1 + this.next.length());
     	  }
     	  else {
     	      return 1;
     	  }
           }
       }

       function Stack () {
           this.head = null;
           this.add = function (x) {
     	  var newNode = new Node(x);
     	  newNode.next = this.head;
     	  this.head = newNode;
     	  return this;
           }
           this.rem = function () {
     	  var old = this.head.data;
     	  this.head = this.head.next;
     	  return this;
           }
           this.length  = 
       }
     #+END_SRC
*** Queues
*** Trees
    
** Testing and Error handling
*** Checking types
    (An important way to deal with preventing mistakes is to ensure that you're getting the right kind of data)
*** Writing specifications
    (we should cover how to define what your code does before you even get started on writing it, the things to consider about types and errors and what contracts it should enforce. Even just the concept of contracts in general for programming)
*** Testing behavior
    (How to write unit tests and describe what your code is supposed to do. Probably include a couple of different libraries for doing this or making a simple one ourselves. In fact, that's a decent project for this section I think: have them use unit testing libraries and then have a walkthrough for writing their own, with optional features and the like)
    
* Advanced Programming Concepts
** Advanced Abstract Data Types
*** Self-balancing Trees
**** Red-Black
**** 2-3 Trees
*** Heaps
*** Hash tables
** Reading Code 
   (In this section we need to discuss how to actually read code and the strategies and exercises for that. 

   I think my own strategies for this are to skim the code and take notes on it. First, identity the main features of the code: what's the first thing called and what does it call within/after that, then take notes on all the other functions involved in that initial setup and take notes on their signatures and what they appear to do, then look at how the functions are called and the names of variables for clues etc. Whenever you really can't understand what something does, attempt to evaluate pieces of it by hand)
** Modules
   (META: The basic idea of modules and how they show up in computer science.
   The essential role of modules is /code sharing/. It's related to how you make libraries work.

   You're trying to control the visibility of code in ways that will /preserve/ abstractions. Now one thing that I think is important is to not cast it as about code "safety" per se, which is what I was confused about when I was first learning programming and learned about things like public and private and protected methods. It was first explained to me as being about "protecting" your code, but then my first question was always "but can't someone else just change the code so its not protected?" and then answer is, of course, yes you *could* do that. It's not about protecting your code in the same way that you'd protect your bank account. It's making sure that the gears are shaped correctly before you fit them together. What I mean by that is that it's going to involve figuring out the right interface, the right exposed parts that you want to present so other people can use your data. I mean you could put in a big warning of "DON'T CHANGE THESE FIELDS THEY'RE FOR INTERNAL USE ONLY" but what's better than that? Making it so those parts aren't exposed. When you're operating a car you don't have access to all the internals of the machine but rather the steering wheel, the gas, the breaks, etc. These are very well defined forms of control, well defined interfaces, to the machine. So that being said I think we can present modules the same way: they're ways to control the interface.

   Further, I think we should include closures and modules in the same larger section on code hiding and modularity. Modularity doesn't necessarily need modules, modules and namespaces are just a way of trying to get at "modularity". Ultimately these topics are about how to make libraries. We need to include a section explaining why you shouldn't just put everything in a single file, even though you totally can and, indeed, it's not necessarily a bad idea.

   Oh god, I don't have sections on refactoring yet do I? Oh dang that'd be a good lesson to include along with all the theory.
 )

  
*** Modules in Node
*** Modules in Future JavaScript
*** Faking Modules with Closures
** Refactoring, generalizing, and improving code
   (META: In this section we'll include a lot of ideas on how to make code /better/ once it's already working. Now I've struggled a bit with the idea of this but I've seen it done with *one* intro book before and I thought it worked really well. I think even just taking the projects up to this point and trying to explain how to improve the code and break it into multiple, reusable, pieces would be a really good idea. Of course, that means we'd be having to explain a /bad/ way to do it first wouldn't we? I mean, I guess, but not entirely. It wouldn't necessarily be involving a bad solution, but rather a solution that just isn't as modular as it could. That isn't as general as it could be. The code could still be pedagogically solid while still having room for improvement.)
** Testing and proving
** Polymorphism
   (META: I'm not sure if an explanation of polymorphism would fit into a description about modularity, about functions, or about ideas of interfaces. It could be any of these, really. Ultimately though we want to talk about the idea of code being able to operate on many different types because it's really only requiring certain methods to exist for the data)
* Classic Programming Problems
** Sorting
   We should include a few different kinds of sorting algorithms along with visualizations for them and how to analyze them
** Searching
   (META: basic issues of search tie into sorting, and are indeed the best motivation for sorting. Beyond that, though, we'll talk about data structures that make search easy. We can talk about self-balancing trees, binary search trees, things like that. We could also talk about the problem of trying to find, say, relevant text in a document or something like that. It'd be a little similar to how search engines work online where we'd look at synonyms)
** Graph Problems
   (there's a million and one problems that come down to graph traversal and manipulation, and any two or three of them would be great for teaching how to deal with algorithms and think of coding. )
* Standards and formats: making the world go round
  (META: In this section, we'll discuss the ways in which file formats and various standards fit into how the world of programming actually works. We'll talk about things like SVG, XML, STL, OGG, and the like in terms of how they operate and how they affect things. We can talk about the general concept of standards, of how to read them, and of /why/ standards are necessary. 

  It might be kinda dry but we'll tie it into projects and the like. For example, we could do a small project that involves MIDI and actually make little songs programmatically. It'd be cute to be able to do something like that. Obviously it wouldn't be as intense as something like Sonic Pi, but it could still have some fun features. We could make a program with a little user interface that would let us type out music or even do something interactively. )
* A bit of theory
  (One thing that would be nice is to include some real segments on the theory of computer science. I could always resurrect my old project on writing a simple programming language for Turing machines. The basic idea of that is to take informal descriptions of Turing machine algorithms and actually make them something you can write down and then "compile" it to the finite automata with tape that corresponds to the program. 

  One reason why I think this idea could work is that it would create a really nice physical demonstration of how a Turing machine works. If you compile to a Turing machine configuration I think it'd explain a lot about how Turing machines can even do the same thing that the lambda calculus or a memory-instruction machine can do. It really wasn't obvious to *me* at least that they're /really/ the same thing in strength. 

  Other things that might make sense in a theory section are: an introduction to the lambda calculus with an explanation of how it works and how it can model any function. The rules of the lambda calculus are so fundamentally simple that it's always a nice mindblowing experience to see what they can do.

  Even beyond that? It might not be a bad idea to introduce a simple pseudo-assembly language that describes how the machine works. )
* Indices
** Be The Interpreter
*** General Rules and Setup for Interpreting a Program
    First, mark down a box labeled "current line". Every step you take, make a note of what line you're on.

    You'll start at the first line of the program and, unless some rule specifies otherwise, go to the /next/ line of code after you're finished with each line.

    Also make a special section labled "output", which you'll use every time something is written to the console by the program.

    If a line of code is an expression *only*, evaluate the expression as normal then *throw away* the return value of the expression.
*** Variable declaration
    Look at your program. For all of the instances you see of ~var name~ or ~var name = expression~ (that isn't in the body of a function (and if you haven't seen functions yet, don't worry)), make a table that looks like

    | name1 | name2 | name3 | name4 | ... |
    |       |       |       |       |     | 

It should have one column for each variable name. 

You don't actually fill anything *in* to start, instead if there's a ~= expression~ portion of the variable declaration you wait until the line in question is reached before filling in the entry in the table according to the rules of the assignment expression.
*** Expressions
    If an *expression* is the only thing on the line, evaluate the expression according to the appropriate rules for that expression.
**** Arithmetic
     Numbers evaluate to themselves. Arithmetic operations evaluate exactly according to their  them to: ~+~ is addition, ~-~ is subtraction, etc.
**** Strings
     Strings evaluate to themselves. The ~+~ operator "concatenates" two strings together.
**** Booleans
     ~true~ evaluates to ~true~, ~false~ evaluates to ~false~. 

     The boolean operator ~!~ takes an expression. Evaluate ~! exp~ by first evaluating the expression ~exp~. If it returns a truthy value, then return ~false~. If it returns a falsy value, then return ~true~.

     The short-circuiting operators ~&&~ and ~||~ have special rules. ~exp1 && exp2~ is evaluated by first evaluating ~exp1~, if it is truthy then evaluate ~exp2~ and return its value. If it is falsy, then return the value of ~exp1~.

     ~exp1 || exp2~ is evaluated by first evaluating ~exp1~. If it is truthy then return the value of ~exp1~. If it is falsy then evaluate ~exp2~ and return its value.

     As a reminder, falsy values are ~NaN~, ~null~, ~undefined~, ~0~, ~""~, and ~false~. Everything else is truthy.
**** Assignment
     Assignment is always of the form ~name = expression~. First, you evaluate the expression based on the kind of expression it is, then fill whatever value it returns *into* the appropriate entry in the table.
     
     The value you wrote into the table is also the value returned by the expression.

**** Output to console
     For purposes of "being the interpreter", we're going to treat the function ~console.log~ as a special operation. When you see an expression of the form ~console.log(exp)~, evaluate the expresion that is the argument, then write the value in the output column you've set aside. As an expression, ~console.log~ returns ~undefined~. 
**** typeof
     The ~typeof~ operator takes an /expression/ as an argument. Evaluate this expression is and return, as a string, the type of the value returned according to the following rules
     + numbers return "number"
       + this includes ~NaN~ and ~Infinity~
     + strings return "string"
     + undefined returns "undefined"
     + objects return "object"
     + booleans return "boolean"
**** Variables resolution
     To evaluate a variable, you have to first consider where the variable's ~var~ statement is and you then you examine the corresponding table that you made. If there is an overlap in names between two tables that are both visible from a point in the code, precedence goes to the more recently created table.
**** Function calls
     A function is called when it is passed zero or more arguments. For example, ~fun()~, ~fun(1)~, ~fun(1,2)~, etc. are all valid function calls.

     A function call is evaluated by:
     1) substituting the passed in values for the arguments of the function, which means everywhere the formal argument was seen in the function body, rewrite it to be the corresponding value
     2) evaluate the body like you would a new program
	1) make a variable table
	2) evaluate each statement sequentially
	3) if there is a return statement, then *stop* executing the function, go back to the point of where the function was called and hand back the value of the expression passed to the ~return~
	4) if there is no return statement by the end of the function, return ~undefined~

***** A caveat on variable tables for functions
      After exiting the function, if there is nothing else that can reference the function's local variable table, then you may erase the table.

      If, on the other hand, that table is still visible to some entity in the program, you may *not* erase it and must keep the variable table in play.
*** Object specific expressions
**** General object layout
  An object is represented as a table a list of pairs of 
     + a property name
     + the value corresponding to the property

**** Objects and variables
     An important note about variables and objects. A variable never holds a literal object. Instead, what the variable contains is an "arrow" that points to the object. The "value" of an object is, then, simply the pointer rather than the object itself.

     The implication of this is that there's no 
    
**** Object creation with new
     Objects can be created using the ~new Constr()~ syntax. This is evaluated by
     1. creating a new object
     2. setting the ~.constructor~ property to the constructor function
     3. running the constructor function with ~this~ bound to the new object
     4. returning *a pointer to* the new object after the constructor function finishes running

     An object created with the ~{}~ or ~{ prop : val, prop : val, ...}~ syntax is equivalent to an object created using ~new Object()~ that then has the corresponding properties, if any, set.
**** Object property access and assignment
     An object's properties can be accessed through two methods: the "dot" syntax ~obj.prop~ or the "array" syntax ~obj["prop"]~. These are evaluated identically, the only distinction is the names that are allowed to be used for the properties: the array syntax is far more permissive with allowed names. 

     You evaluate property access by looking up the value of the property in the object and returning it. If the property isn't in the table corresponding to the object, first check the prototype of the constructor of the object. If the property isn't in the prototype or the prototype's prototype etc., then return undefined. When searching for a property, the first place you find it takes precedence and you return with *that value* immediately and do not continue searching up the prototype tree.

     You evaluate property *assignment* by first evaluating the expression to the right of the ~=~ and putting that value into the table corresponding to the object, making a new space for the property if there isn't already one in the object.
**** this
     The statement ~this~ acts like a variable with special evaluation rules. There's two different ways in which ~this~ can be used
     1) in the constructor of an object
     2) in a function to be called *by* an object

In the first case, when ~new Cons()~ is called to make a new object using the constructor ~Cons~, ~this~ is a reference to the fresh object that is being constructed. See also the section on object creation.

In the second case, when a function is called *as a method*, ~this~ points to the parent object. 

If ~this~ is encountered outside of these two cases, then it resolves to the "global object" of the program.
*** For loops
    A basic for loop has the form
    #+BEGIN_SRC js :exports code
      for (initialization; condition_for_continuing; next_step){
          statement1;
          statement2;
          statement3;
          ...
      }
    #+END_SRC
It's not *strictly* required, but you should make the "initialization" code only be of the form ~var name = exp~ or ~name = exp~. The condition for continuing the loop should be an expression that returns a boolean. The next step slot should be an assignment expression that modifies the variable named in the initialization.

The rule is that you 
   1) execute the code in the "initialization" slot
   2) evaluate the condition for continuing
      1) if it is truthy, go to step (3)
      2) if it falsey, jump to the line of code *after* the end of the for loop
   3) execute the statements in the for loop
   4) execute the code in the "next step" part of the for loop
   5) go to step (2)
*** While loops
    A while loop has the form
    #+BEGIN_SRC js :exports code
      while (condition){
          statement1;
          statement2;
          statement3;
          ...
      }
    #+END_SRC
The rule is that you
   1) evaluate the condition
      1) if it is truthy, go to step (2)
      2) if it is falsey, jump to the line of code *after* the end of the while loop
   2) execute the statements in the while loop
   3) go to step (1)

*** If statements
    If statements have the basic form
    #+BEGIN_SRC js :exports code
      if (condition){
          statement1;
          statement2;
          ...
      }
      else {
          morestatement1;
          morestatement2;
          morestatement3;
      }
    #+END_SRC
    The rule for them is that you

    1) evaluate the condition
       1) if it is truthy, perform the statements listed between the braces of the "if"
       2) if it is falsy, perform the statements listed between the braces of the "else"
    

The other form of if-statement is to leave out the ~else~ branch. In this case, our rule reads

    1) evaluate the condition
       1) if it is truthy, perform the statements listed between the braces of the "if"
       2) if it is falsy, do nothing
  
*** Function declarations
    There are two function declarations. There is the *expression* form which has the following syntax 
    #+BEGIN_SRC js :exports code
      function (arg1, arg2, ...) {
          statement1;
          statement2;
          statement3;
      }
    #+END_SRC
 This evaluates to a function value, which in our pen and paper we'll represent as a box that
    + contains the list of arguments to the function
    + the lines of code for the body of the function
    + an arrow pointing to the variable table within which the function was defined (this is important for calling functions!)

The second kind of function declaration, which is a *statement*, is the named function declaration, which has the following syntax.
    #+BEGIN_SRC js :exports code
      function name (arg1,arg2,arg3) {
          statement1;
          statement2;
          statement3;
      }
    #+END_SRC

You evaluate this by treating it as equivalent to 
#+BEGIN_SRC js :exports code
  var name = function (...){
     ...
  };
#+END_SRC

** The Lambda Calculus
*** Universal Computation
*** The Core Language
*** Data in the Lambda Calculus
*** An Interpeter in Javascript
* Proposed projects
  Since my urlminder goal can't change to look at multiple files (I guess?) then I want to just keep tracking my other writing for this book in this file but near the end! Neat!

** Tumblr API                                                      :noexport:
   In this project we'll go through and develop a simple library that allows you to post to Tumblr from your console program. 

   We'll cover the idea of APIs for websites, we'll talk about HTTP and communication over the internet, and we'll talk about how to read an API and discuss it.

   What's good about this chapter? It'll talk about how to build something practical from scratch and learn more about how the modern internet works. That'd probably be useful for explaining a lot about interacting with websites and demystifying a number of things that I think feel like "magic" to beginning programmers.
** A bug finding program
   The goal of this project is to learn a little bit of how static analysis works. Not very deep, but little things like analyzing whether every branch in a function has a return statement or things like that. Checking to make sure every variable used was defined first. Things like that. The main idea is to get across the idea that programs are things that can be /analyzed/ and understood in their own right.

   The corresponding chapters will cover over the idea of /parsing/, the limits of computation, and how to design datastructures for a complicated task like that. 

   Maybe we could even introduce graph problems by putting together graphs of where variables are used in a program? That could potentially be interesting. 

   I suppose there could be some kind of working in dead code elimination. At least a simple one. 

   After that, then we can talk about why we can't find /all/ possible bugs in code by discussing the halting problem. Heck, we could even maybe propose a way to do "halting analysis" and show why it can't work in general.
** Creating shapes for 3D printing
   This could involve writing a little library for writing STL files, for understanding STL format, and then for being able to simple shapes in code and do cool things like that and turn them into something physical.
** A roguelike
   The goal of this section is to describe a /complicated/ text based game. We'll introduce the concept of a roguelike and then build up the things we'll need to make it.

   In this section of the book we'll introduce 
   + the concept of data structures
   + objects
   + classic datastructures like lists and stacks and queues and trees and graphs
   + introduce things like sorting problems and graph traversal to do things like display your inventory or figure out how to represent rooms in the game and how to move between them. We can even show how graph traversals can tell us about whether the procedurally generated map can actually be traversed from the beginning to the end. Heck, we can even include a bonus chapter about "challenge maps" in which doors can only be used once and then let that lead into a discussion of hamiltonian paths

** A midi project
   The midi file format is also very easy to read and understand. We could always take a page out of one of my favorite texts to deal with writing little mini-languages for music. We could show that it's possible to do things like
   + generate music from sentences
   + write music as a program
   + write a programming language that will "compile" to music
   + read in midi files and transform them in some way
     + I'll be honest I often think of that project I heard about where a violinist working on his MFA did a rotation of a musical piece and then played it for his final project. It's a very cool idea and we could lead students in a project like this. 

   http://cs.fit.edu/~ryan/cse4051/projects/midi/midi.html
   https://en.wikipedia.org/wiki/MIDI

* Meta Notes                                                       :noexport:
  This section is for commentary that doesn't yet fit elsewhere in the book
** A project based organization
   I'm thinking that we should reorganize the text to be "by project". Like different sections introduce projects and then we give all of the concepts and skills that are needed for the project and /then/ we actually explain how the project works at the end. 

   So in this case I think the book might look something like
   * Intro to Programming
   * Physics simulation: using libraries, iteration, and control flow
   * A roguelike game: objects, datastructures, file formats, and parsing
   * A console-based Tumblr client: APIs, modules, and creating your own libraries
   * A bug finding program: programs that read programs and the limits of code
   * Making a simple assembly language: how computers work under the hood
   * Generating 3D Printer Designs
** An argument for a polyglot book
   Now, so far I've just been working from the assumption that this entire text will be using /JavaScript/ and no other language. Well, the very earliest versions were going to be Python but I ended up deciding that I didn't like Python as much as a first language. Nothing particularly against the language itself, but there's reasons why I didn't want to teach it as a very first language.

   Now the advantage of teaching with only a single language is that there's automatic unity in presentation between concepts. Only one language means only set of syntax to teach and only one way you need to teach ideas. 

   On the other hand...is that really a good thing?

   Is it just my own biases that I think seeing how to program in multiple ways helps you get away from the particulars of a given language to understand the way to program in /any/ language?

   That's how I feel at least, but is the project of writing a rosetta stone book that could exist in multiple languages, that could show how the same concepts could be expressed in multiple languages. We could then explain the /ideas/ of recursion, iteration, and of data abstraction and how they can be done in different languages. We could get at the core ideas, perhaps.

   What languages would be good for a polyglot book? I'm thinking that JavaScript, Clojure, and maybe even a language like Ruby or, if we wanted to get creative /Erlang/ and then actually go through the material in multiple ways.

   So, for example, in the section of the book that's about modules and code hiding: we can talk about how closures, how classes, and how private fields and methods combine together to provide the ways we define our interfaces. Again, that's the key word that we need to address: interfaces and how to define them. I feel like that'd still make sense as a concept no matter which language you're using. If anything we could explain how different languages explain this. 

   We could talk about functions *and* meta-programming as being about code reuse. We could talk about meta-programming as both macros and the kind of classes-as-first-class programmable objects that we have in Ruby or JavaScript. 

   We could also include things like data abstraction and talk about tagged lists with or without symbols vs. objects vs. classes. All of these things accomplish the same task but in different ways with different strengths and weaknesses. Although, I'll confess, we could already explain some of these ideas by just picking a language and going with it.
 
*** An argument *against* a polyglot book
    So the biggest argument against a polyglot book is that it adds massive complexity for both writing and potentially reading. There's a serious danger of losing the story by focusing on a least-common-denominator that makes sense for each language rather than dealing with the full scope of what we want to cover. We don't want to get bogged down in making examples in multiple languages if it's going to just pad out the text without a strong payoff.

    One thing that's going to get /very/ lost by doing a polyglot book is that we won't be able to include any of the proposed operational semantics techniques that I really wanted to include. Otherwise we'd have to include the operational rules for /three/ different languages, which isn't exactly a nice and pedagogically sound goal.

    What's lost if we don't include operational semantics? Well, the most obvious thing we'd lose is that we wouldn't have the intuition building of pen & paper exercises that show how to calculate from code to output. I think these exercises would be one of *the* most important and uniques aspects of this text. Admittedly, I haven't gotten to actually try out teaching a class this way which is unfortunate but I really do believe we could structure this book like a *good* math text. We show how calculations work. We demonstrate how to understand line-by-line evaluation of code. We demystify the entire programming process. That'd be a heck of a thing to give up from the text. 

    Speaking of exercises, though, there's also the argument that having multiple languages will also complicate the projects and the individual exercises. Do we provide exercises in just one language? In all of them? Do we have ssome exercises in one language and others in the other languages? It's not obvious that this'd be good for pedagogy rather than just adding a lot of confusion over time. 
** Another outline
   Here, let's take another shot at a new outline that focuses more on /projects/ and /concepts/ and less on introducing syntax
*** Introduction
**** What is programming?
**** Why learn it?
**** What are programming languages?
**** Syntax vs. semantics
*** Project 1: Description
    Here we can include the description of the problem for the first project. There's a few possibilities here, like the physics simulation project where we can graph some data and show how useful functions are and even connect it to wanting to make games or more cool things like that.
*** Basic programming
**** Input and output
     One of the big decisions here is whether we want to be explaining console based methods of communication or 
**** Kinds of data
**** Control flow
***** Functions
      Cover functions before for loops? Honestly, why not? I mean in some ways functions are the /most/ fundamental control concept and yet they're so rarely presented that way.

      If we start with functions we can show that while loops and for loops are just syntactic conveniences for the way functions work.

      We can also immediately explain anonymous functions and tie them into these other iteration constructs.
****** Functions by hand
****** Scope
       A lot of our description of scope will come /after/ we describe the by-hand evaluation rules, since it's going to make more sense I think to describe the implications of scoping rules if we've already seen physically how it works
***** If-statements and booleans
      We'll introduce booleans along with if-statements because they really don't make sense without the ability to define branching. We'll include all our basic booleans operators as well as introduce equality and comparison operators. It'll be a chunk of cognitive change, but I think it'll be good going forward
****** Why we need branching
       Explain the need to make choices and how to know when to start or stop an action. 
****** Booleans and logical operators
****** If-statements
****** Recursion
       How intuitive can we make the concept of functions calling themselves? I feel like it's not actually that bad of a concept if we don't present it as something scary.
       Maybe comparison to how you might explain addition would be helpful: e.g. addition is repeatedly adding one with a recursive definition. Of course, recursion might not be useful until *after* we explain how branching works since without some form of branching you can't actually cut the recursive chain. 

***** For-loops
      We'll cover very basic C-style for loops rather than the for-in or for-of loops. We can cover those later, but they're not necessarily important first contexts
****** for loops by hand
****** for loops with functions
       this should be an aside how branching + functions can be used to replicate the use of a for-loop. Talk about why you might want to use one and not the other in different situations
***** While-loops
      We'll be covering while loops only and not the do-while loop, since it's just redundant with the fragment of the language we're describing. 
**** Project 1: Implementation
     Here we can actually explain how thse basic concepts from before can be put together to make the full project. 
*** Intermediate programming
**** Project 2: description
     Project 2 should be a project that involves a /lot/ of data manipulation. This might be a good time to do something like the midi project or the stl project, where you're dealing with file formats and modelling data. 
**** The need for aggregate data
     Before we get into the next topics of aggregate data types such as arrays and objects we need to first talk about what it means for 
**** Arrays
     Basic list-like operations and all of that. We can talk about the uses of lists for storing varying quantities of data and how arrays fit into iteration. We can probably even introduce things like folds at this point. 
**** Objects
***** Objects as collections
      The most basic use of objects is as a form of /map/ or /dictionary/ that associates keys with values. Now, obviously, there's a lot more to how objects work but there's a lot of ways you'd use objects that really just come down to objects-as-dictionaries
***** Constructors
      We can't explain *everything* about constructors yet, at least not without =this=, but we can lead /into/ this by trying to first explain that a constructor is a function that /makes/ objects and then once we introduce =this= we can start using the =new= command to create objects and assign values
***** =this=
      The hardest thing to explain here is going to be the fact that =this= scopes so completely differently. I think teaching the by-hand method of using =this= is probably the best bet for actually giving some intuition.
***** Methods
      Once we've explained =this= I think we're in a good position to talk about the interesting aspects of defining methods and how they interact with =this=.
*** Data abstraction and interfaces
    This chunk of the book is going to be about data organization, designing interfaces, and why we "hide" implementation and exposure the interface instead. We'll be talking about /inheritance/, about /modules/, and about using closures to hide and control data. 

    We'll also talk about the idea of abstract data types and how they can have multiple implementations
**** Project 3: Description
     I think the thing to implement on this section is the rogue-like game. We'd be able to do some cool graph theory problems here as well as practical implemention of a REPL and include organizing our data into modules and interfaces. We can keep it fairly simple, but still include enough in terms of enemies and obstacles and about how to design maps that we can actually demonstrate a lot of these ideas. 
**** Interfaces
     Explain the basic idea of an "interface" and why you want to describe one. Now, JavaScript is a language that doesn't have a formal type-level notion of interface but interfaces still matter in terms of the collection of methods and properties that certain objects should have. Implicit interfaces is the very idea of "duck typing" as folks call it!
**** Modules
     We can talk about two forms of modules here: the node-style modules and the new standard of modules. 
**** Closures
     Explaining the idea of holding *state* with closures. We explain how closures work pretty simply with the mechanics of scope in the by-hand operational semantics. 
***** Inner and outer functions
      The entire machinery of closures is fundamentally about the interaction within layers of functions
***** Closures are a consequence of scope
      The by hand rules of scope will make it very obvious *why* the variables declared within the outer function are visible from the inner function 
***** Faking modules with closures
     The point here is that by having data hiding with closures then we can have a very specific /interface/ to the data. We can show that we don't technically *need* modules. 
***** Closures + Constructors
      Closures and constructors together can do all of the cute tricks of making both public and private data.
**** Abstract Data Types
     The big things here are, again, about the idea of interfaces and specifying how types of data should behave in the /abstract/ and then provide a number of ways for how to implement them. 
***** Complexity and asymptotics
      Ah, yes, no book would be complete without having to deal with big-O notation and analyzing algorithmic complexity. It's not a terribly interesting topic, but it's an important one to teach. Rather than having dedicated sections on it maybe it'd just be nice to figure out ways to slowly work it into our operational semantics approach
***** Stacks, queues, and lists
      We can show how to implement these with arrays as well as linked lists. We'll explain here how to do linked list data structures in JavaScript. Now that's a concrete data structure not an abstract, but it demonstrates an important technique for understanding references and complex data structure implementation 
***** Trees
****** Trees as ADT
       This will also be a big case study of how ADTs work because we'll explain the /interface/ of trees and then we'll talk about the implementations therein.
****** Binary search trees
       What we need to cover here is the use of trees in storing and retrieving data. We can talk about the efficiency difference when it comes to finding data.  
****** Self-balancing trees
******* Red-black trees
	We don't have to spend a *massive* time on red-black trees, but I think at least showing that this is the kind of thing that programmers have to invent for specific purposes is, I think, a good idea.
******* B-trees
	I don't know if we really need both red-black trees /and/ b-trees but it might not be a bad thing to write both sections and then figure out what we want.
***** Graphs
****** Graphs-as-adts
       So we need to explain the /interface/ of graphs and then about the various ways you can represent graphs (inductive definitions, adjacency matrices, or linked like the way we deal with linked lists) and how this effects the kinds of things that we can do efficiently with graphs. I'll concede this is an area of programming I don't have a ton of experience with but I think we can come up with some interesting things. It's going to depend a lot on the motivation.

       Motivation? Perhaps something like understanding social networks? In some of the texts I've read on social networks there were neat examples of figuring out who's actually the most important person in the network or things like that. There's delivery routes as well. 

       Oh, right, I had an idea of explaining how to figure out if you were generating proper maps for a rogue-like game. Like figuring out what the connected components are and if the exit and entrance are both in the same connected component. Or if you've got a messed up setting that involves a bunch of "one way" passages using Hamiltonian paths to determine if the path is even solvable. Those kinds of things. 
****** Hamiltonian paths
****** Connected components
**** Project 3: Implementation
*** Classic problems
    This might get blended into other sections, to be honest. What I want is to include some of the classic "you're taking a class on algorithms" problems. We can include topics like sorting and search through data structures, but I think those are also topics that are just so /very/ close to what we'd cover in the ADT sections themselves
**** Sort
**** Search
*** Interacting with the real world: APIs and standards
**** Project 4: Web app
     I'm not sure what'd be good for this. Maybe something like Tumblr because it's complicated enough. We can walk through the idea of making posts and getting user information. Heck, we could even do something like the "bubble burster" app that finds people on the periphery of the social network for you to try following instead. 
**** Web APIs
     The general concept of an API as well as how it ties into the more common notion of an API for web-apps. 
***** HTTP: the short version
      All we really need to explain here is the basic structure of requests, what they mean, and how we need to make them. 
***** An example API
      Maybe tumblr and one or two others
**** Project 4: Implemntation
**** Project 5: STL and 3D printing
     This is, I think, where it'd be great to talk about two different file formats. We can talk about SVG, since it has a beautiful and simple structure when you get right down to it. It's the legos of image construction which is why vector graphics programs have the form that they do. 

     Beyond that, there's also the stl format we've discussed which is perhaps a bit harder to visualize but still interesting in its own right. What I think might be interesting is explaining how to read and maybe visualize the stl format from a file? To display something already made? That alone might be enough of a feat to be worth the price of admission of the chapters
**** File formats
     Here we want to talk about things like what standards for file formats are and how the structure of data in these standards decides so much about how technology communicates with each other. Now, this isn't material that's generally included much in introductory programming but I think it'd be useful for acting as a /pineal gland/ that connects the rareified world of pure computation with the world of practical and useful programming. It's something that I found personally confusing when I was first learning to code. 

     I suppose that's another thing to consider as we're writing this text: the best calculus books were the ones that had constant visualizations and small exercises and examples that could help you remember why the math was being used the way it was. I sometimes miss the feel of a good math or physics text when I'm learning more & more computer science. I feel like even books on algorithms aren't very good at this when they are literally /full/ of real world applications.

*** Reading code and Writing comments
    Here we need a good section on how to /read/ code. Ways to understand programs and how to explain to others how code works. I'd like to demphasize the whole mess of "long descriptive variable names", which I personally think can get pretty over the top once we're having to use multiWorldVariableNames that are hard to scan instead of making the code easy to scan and easy to understand the logic thereof. 

    Yeah, I know this is a somewhat opinionated proposal but I have Strong Opinions about this. I suppose, though, the most important thing is to emphasize the idea that one should write code that is easy to read. We can give "soft skill" exercises like the ability to write out what code does just from reading it carefully or suggesting that they write code and then, a week later, try to go back and read it and understand what it did without comments. 

    That's a slightly odd exercise but one that I think would be very instructive. 
*** Testing and proving
    So this might be a neat section to both talk about ideas of /testing/, like unit testing and integration testing, vs. /proving/ via static analysis or tools like that. No, I won't delve into proof theory because I don't think that's a very good idea for a beginning book that's assuming no mathematics, but I think at least giving an indication of what can be known versus what can only merely have evidence for might be a good and interesting distinction. At the very least it's nothing that I can imagine has been done before in an introductory text.

    Also, as a note to myself I should look into what's considered the "best practices" in terms of JavaScript testing frameworks right now. Mocha, Jasmine, and QUnit *seem* to be ones folks use but I'm not sure which would be useful for this book. I'd want something that demonstrates the /principles/ without getting bogged down in too much overhead. There's probably some kind of quickcheck or fuzz testing type framework that we could easily use. 
**** Unit tests
     So we need to explain the concept of unit tests, go through at /least/ one framework for it, and then explain how they relate to the basic concept of "interfaces". 
**** Fuzz testing
     What happens when your program is hit with arbitrary data? Does it behave appropriately or does it choke and die? The best way to know is to just throw data at it and /see what happens/. We'll cover a framework if we can find one, and we could always run through the idea of creating one from scratch.
**** Project: Creating a unit test framework
     Yeah, I'm stealing a bit from Peter Seibel in that I think creating a little unit test project would be a just *fantastic* way to get some more advanced coding techniques in there. It doesn't have to be a fully featured framework but even just something that allows you to take a function, supply a condition for what the result should be, and then coalate the results together in some useful way. 
*** A bit of theory
**** The limits of computation
     Here we can cover one of my favorite topics, which is what the real limits of computation are. So we can explain what isn't possible and give intuition for /why/. 
***** A simple proof 
     A diagonalization argument like in the talk I'm giving. We can present how the diagonalization argument works for numbers and then bump it up into programs that analyze other programs and from /there/ we can show how either there's uncountable programs (there's not) *or* the problem must have been assuming that being able to write a program that could analyze all other programs must have been false. 
**** Turing machines
     A description of Turing machines in words, pictures, eventually leading to introducing a small little programming language that explains "what" is easily definable in the automata nature of a Turing machine. Part of my concern is giving better intuition. I think describing a language and turning it /into/ the automata would be a nice little demonstration of this fact. 

     The basic structure of the Turissembly lanuage would be something akin to describing the action on the tape in words like "move left until =cond=" or "if readCurr() then goto =lab= else goto =lab=" or things like that. 

     As notes to myself, I'll say that it's probably best if we write the language in a compositional way where we can compose the turing machine automata pieces together as much as possible. I don't actually know if it'll be possible to stitch them together like that but at the very least it's a goal of the project.

     After the walkthrough of this "turing language" our project could be walking through the actual /implementation/ of this system and exercises of how to program in this language.

     The other possibility, of course, is that we just *provide* the Turissembly implementation rather than walkingthrough how to write it in the first place.

***** A turing language
      So we need a programming language that can easily map down to the state machine description of Turing machine. 

      We need 
        + case statements (over the alphabet of the language)
	+ a statement for reading the current data
	+ a statement for creating a loop
	+ a statement for writing into the current place
	+ statements for moving right and left

We need to do something like

#+BEGIN_SRC haskell :exports code
  data Dir = Left | Right

  data Val = Char Char | 

  data Expr = Case [(Char,Expr)]
            | 
#+END_SRC

Okay, so part of what I'm trying to figure out is what the structure of this language would be. I think a program is going to need to be a group of /functions/. The different functions are going to be, essentially, "clusters" of states. Each function will involve calling other functions. I was going to suggest having a built in operation that "reads" in the data in the current cell, but I realize now that's not really necessary just because it can only be used once per function. Instead, I think it just needs to be used in the "case" statements. I think one thing I'm having trouble picturing is how the hierarchy of syntactic forms is going to have to look.

So I guess we could do a thing of having every function start with a case statement and then the end of the sequence of statements for each case statement has to be moving in a direction and then (optionally) another function to call. You could have a thing, though, of a function /either/ has to be a case or a loop around a case or just calling another function. Maybe that'd work?
      
**** The lambda calculi
     So we *don't* want to spend a ton of time on lambda calculi because that's an incredibly deep topic in and of itself, but in just like 10-15 pages we could explain the entire lambda calculus and how things like the peano encodings of data actually work. Since we'll already be really familiar with operational semantics and all of that, it won't be hard for us to go ahead and introduce the rules for beta-reduction and how that works. 
**** Assembly languages
     We can explain how assembly languages work, what it means for code to execute in the processor itself and then go over what a simplified assembly language would look like and how it would be implemented. Even if we don't do the turissembly project from scratch (of close to it) I *definitely* think we should have a project where we go through how to implement the basic assembly language *from* it's operational semantics. 

* Footnotes

[fn:6] You might be thinking "but of course I can grab wherever I want in a stack of handouts or plates", but think of it as what's /natural/ to do. If you're in a line at a cafeteria, you're going to grab the tray or plate on the top. If you're grabbing handouts for a class, you're going to grab the very first thing. 

[fn:5] Shapes as examples of object oriented programming are ubiquitous to the point of being a joke in and of themselves. I promise that almost every book you ever read about programming in a language with objects /will/ mention squares and circles and rectangles at some point. Who am I to buck the trend?

[fn:4] I actually once worked with a person who /insisted/ that a program was at its best when all extraneous space was taken out and it was all written on a single line. He believed this so strongly that he would smugly edit other people's code to remove all readability because it made code "real". I beg you to never do this.

[fn:3] Further information of visualization in JavaScript can be found in the book [[http://jsdatav.is/intro.html][Data Visualization in JavaScript]]

[fn:2] This is a related but distinct concept from another thing you might have heard of: modules. Modules are a common way to /organize/ the code from different files in order to do things such as prevent name clashes between the present code and library code, control what parts of the library code are used, and make it visible at a glance what code is in the current file and what code was written elsewhere and other uses

[fn:1] I find it rather unfortunate that the word "variable" has these two, very different, meanings in computer science since variables-as-containers could probably be more accurately called "references", since they are special names that *refer* to a location in memory. 


