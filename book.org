#+LATEX_CLASS: book
#+LATEX_HEADER: \usepackage{proof}
#+AUTHOR: Clarissa Littler
#+TITLE: Introduction to Computer Science in Javascript
#+OPTIONS: toc:nil

* Introduction
** The Goals of This Book
   The fundamental goal of this book is to teach the basic ideas of programming and computation in a way that's both mathematically rigorous and still understandable to anyone who's had even a single term of algebra. 

   My goal in /writing/ this book is to try and demystify the process of programming. I basically want to write the book I had wished I'd had more than a decade ago when I was first learning to write code. Back then, I was working on my master's degree in physics and I needed to modify some programs for a simulation we were running. I read some online tutorials for C++ and Fortran, the two languages we used, and managed to eventually lurch my way to my first working code. Even though I ended up writing working programs, I still didn't understand /why/ the lines of code needed to look the way they did or why all the previous attempts I'd muddled through /didn't/ work. I had no way of predicting what a program was going to do until I ran it.

   It wasn't until a number of years later, as I started teaching myself other programming languages such as Common Lisp and Haskell, that I began to understand the fundamentally mathematical nature of programs. I learned that programs /have/ rules and they're not (entirely) arbitrary. I learned that I could predict what a program was going to do even before I ran it. I figured out how to evaluate pieces of code with pen and paper before even typing anything. Finally, I discovered that not only are there rules behind every programming language, but there are in fact meta-principles that govern most programming languages and how to learn them. There are underlying principles behind /computation/ and different styles of programming languages merely take different perspectives on how to describe those underlying computations.

   To this end, I take a mostly neutral stance on choice of programming languages and styles of programming. I don't believe that there's a "best language" for everyone, but I do think any given person or team may find that a particular language is best for the way they think and the way they conceive of computation. 

   On the other hand, we have to pick a particular language in order to write this book and to that end I've chosen the Javascript programming language. 

Ultimately it is my hope that after reading this book it should be relatively simple task to learn any language you want and know how to write the programs you want to write in it.
** Outline of The Book
   Part 1 of the book proper is going to be centered on the basic built in operations and kinds of data that exist in Javascript and the /structure/ of programs themselves. We'll be covering
  + basic operations on numbers
  + how to makes choices
  + how to define functions
  + reading input into a program
  + printing output from a program
  + how to repeat actions
  + how to use objects to store data
  + how to encapsulate data using functions and scope

Part 2 of the book will be more advanced topics including:
  + advanced use of closures
  + prototypes, inheritance, and object oriented programming
  + the use of data structures such as dequeues, graphs, and heaps

Part 3 of the book will be a sequence of programming projects that will help connect all of the main topics together.
** Getting Started in Javascript
* The Basics of Programming
** What Computation Is
   Before we start explaining the details of Javascript we first need to give a basic explanation of what we /mean/ by computation. 

   Essentially, a /computation/ is a process that takes a finite number of steps to perform an action. In its most general form, a computation is allowed to be interactive, receiving input at a number of points and returning output. 

   Now, we mostly associate computations with /computers/ but a computer is to computation as a calculator is to arithmetic. It's convenient to use, but not strictly necessary. Consider how we add two numbers together. If we were to describe the finite /process/ of adding two generic numbers it might go something like "to add ~m~ and ~n~ we add 1 to ~n~ a total of ~m~ times". This gives us a procedure that describes what addition means, assuming that we know how to add 1 to a number. Similarly, we can describe multiplication as a finite process by appealing to addition "to multiply ~m~ and ~n~ we add ~n~ to ~n~ a total of ~m~ times".  So for example with this definition of multiplication we can describe 3*5 as 

#+BEGIN_LaTeX
  \begin{align*}
    3 * 5 &= 5 + 2*5 \\
          &= 10 + 1*5 \\
          &= 15 + 0*5 \\
          &= 15 \\
  \end{align*}
#+END_LaTeX
Now this might sound a little unnatural but if you squint at it it's basically just counting by fives, the way you learned how to do as a child. That's because counting by ~n~ is a /computation/ and takes a finite number of steps. 

Other things that count as computations would be
  + sorting your music collection alphabetically
  + keeping score in cribbage
  + balancing your checkbook
  + transcribing a conversation

If it's starting to sound like almost /everything/ counts as a computation, that's because most things are. There's even a hypothesis that every physical process in the universe is, on some level, a computable process. 

Even if that hypothesis isn't true, the purview of computation is still very large and covers a great many things. A good rule of thumb is that any process that can be described as using 
  + a finite number of rule
  + a finite amount of data
  + and a finite amount of time to finish succesfully
is probably computable. If you look at all the previous examples, they fit into those three criterion. 

What kinds of problems /aren't/ computable? One example would be "add up all the numbers in an infinite list and return their sum". It takes an infinite amount of time add up all the numbers in the infinite list, and unless all but a finite number of elements of the list are 0 then it will also take an infinite amount of /data/. Another would example would be creating a table that lists every digit of \pi. This would require an infinite amount of data, and so couldn't possibly be computable. The common theme of all the things that are /not/ computable is that they are /infinite/ in some way. A more pragmatic example actually is inspired by understanding computer programs themselves! It turns out that trying to determine, with perfect accuracy, whether or not a program has a virus is /not computable/, which means that there's no possible way to write a perfect anti-virus scanner.   

On a theoretical level, the fact that so many things are computable is the reason why computers have proven themselves to be so useful to us. 

That's a lot of description of what kinds of things /are/ computable, but what does it actually mean to describe a computation? The rule of thumb we've given is just an informal way to guess if something is computable. We don't know how to /define/ computations.

To define computations, we'll need some kind of formal language much like we had when learning algebra. The language of algebra gave us the ability to write things such as
#+BEGIN_LaTeX
  \begin{align*} 
    f(x) &:= 3*x \\
    g(x) &:= f(x) + 10 \\
    h(x,y) &:= x^2 + y^2 \\
  \end{align*}
#+END_LaTeX
and have these functions be well defined. We know how to apply these functions by /substituting/ in numbers for the variables in the equations as in the following examples.
#+BEGIN_LaTeX
  \begin{align*}
    f(3) &= 3*3 = 9 \\
    g(10) &= 3*10 + 10 = 40 \\
    h(3,4) &= 3^2 + 4^2 = 25 \\
  \end{align*}
#+END_LaTeX

In addition to the ability to functionally define equations, we also have, built-in, all the arithmetic operations such as +,*,-, and the exponential operations. At this point, we need to make a distinction between syntax and semantics. By syntax we mean the literal symbols themselves, as in 
#+BEGIN_LaTeX
  \begin{align*}
    3*4 + 10 \\
    x^2 + y \\
    f(10) \\
  \end{align*}
#+END_LaTeX
Now, if you look at those symbols you can probably guess what they /mean/ when interpreted as numbers but what's literally there are just symbols. + is just +, * is just *, etc. They don't have meaning until they've been /evaluated/. This meaning of the symbols, that assigns the meaning of /addition/ to the symbol +, multiplication to the symbol *, is the semantics of the formal language of algebra. Every formal language has both a /syntax/ and a /semantics/ and our general procedure from here on is to introduce pieces of syntax along with their semantics, so that you may in principle evaluate your programs by hand. 

While we can define many arithmetic functions using this equational algebra and while all of these arithmetic functions are computable [fn:: At least when restricted to a suitable subset of the real numbers], there's many things that this language of functions cannot define. For example, we can only define functions on numbers. We also cannot define functions that are fundamentally interactive, asking for input from some other source.

In order to define general computation, we need a language that is far more complex than just having equations and operations on numbers. Unsurprisingly, this will be our /programming/ language. 
*** Turing's Conception of Computation
    Alan Turing is, arguably, the first person who came up with an easy to understand model of computation. In Turing's day, "computer" was a job title rather than a device. Computers worked out computations, by hand, such as firing solutions for the military. Turing was inspired by the way that these computers worked, where they had a finite but /arbitrary/ amount of scratch paper for their calculations and were able to stop their computation at any point, take a break, and come back to their work later. Abstracting away from these observations, Turing came up with the notion of a Turing machine. A Turing machine is a device that has an infinite roll of tape that it can write on, divided into individual cells where a single character can be written, and a movable head that can move around the tape. 

    A given Turing machine is hard wired to be able to read a single character off the tape and then decide to 
   + terminate succesfully
   + terminate unsuccesfully
   + write a new character into that cell
   + move the head left or right on the tape
   + enter one of a finite number of pre-defined configurations for deciding the next action
The way a Turing machine operates is that it's input is written onto the tape in advance, then it continues to process the input according to its hard-wiring until it either terminates succesfully, with the output written on the tape, or terminates unsuccessfully because the input was ill-formed. 

Given our informal definition of computation above, we can see that this matches what something /computable/ should be. There's a finite amount of data that's used on the tape at any finite time. There's a finite number of rules in that there's only a finite number of things the Turing machine can do in any configuration. Also, if the Turing machine finishes successfully it must only take a finite number of operations.

Turing's machines were not the first or only way to conceptualize computation, there were also the partially-recursive functions and the lambda calculus, but these were very abstract tools for mathematicians that, while they do describe all computations, don't characterize an intuition for what computable things are "like". Turing machines on the other hand give us this intuitive feel for the finite nature of something that is computable. 

** What Programs Are
   We've tried to define what computation is, on some level, but we haven't answered the obvious question on the nature of /programs/. 

   A program is a piece of text in a formal language that defines a computation. I think a good analogy is to consider the computation itself as the process of cooking a meal. A program, then, is the written recipe that describes how to perform this process correctly. You are playing the role of the interpreter, in this case, reading the instructions and figuring out what they mean and carrying them out. 

   There's a major difference, though, between a recipe or directions to a friend's house and a program. The difference is that /you/ are much, much smarter than a computer. A recipe doesn't have to explain every tiny detail of how you boil water, turn on a stove, pulling ingredients out of the fridge, or what "to taste" means for a seasoning. On the other hand, /you/ have to describe in painful detail how to do almost everything for a computer. A good programming language will have a wide variety of built-in kinds of data and operations whose meaning the programming language designer has already defined for you. They work as building blocks that can fit together to make whatever you want. The process of building can still be very, very complicated and tedious and difficult.

   Programming requires a level of precision in thinking and clarity in writing that normal life doesn't require, because in general we're communicating with each other and it's usually quite clear to someone else what you mean even if you misspoke. Computers can't figure those things out. If you misspeak when programming, the computer will do the wrong thing. That is what we call a bug in a program, and they're very easy to cause. If anything, I want to impress on you that programming can be difficult at first simply because for many people it's not a natural way to think. So don't be discouraged if it takes some time to /think/ like a programmer. It wasn't something that came easily to me at first, since I came from mostly a pure mathematics background, but over the years I've grown very confident in my abilities. 
*** A Mathematical Aside On Programs and Infinity
    This is an optional section that is not necessary to understand the text of this book, but presents an argument that I think is fairly useful for understanding the limitations of what a computer can do. 

    We need to introduce a few mathematical constructs that may be unfamiliar. The first of these is a "set". A set in mathematics is an abstract collection of things. Examples of well-defined sets in mathematics are
    + the set of all real numbers
    + the set of all grammatically correct sentences in English
    + the set of chickens named Belina
    + the set of recipes that I've used in the past year
Some of these sets are /finite/, by which we mean we can count them in a finite amount of time. The set of chickens named Belina and the set of recipes I've used are both finite. Some of these sets are /infinite/, such as the set of all grammatically correct sentences and the set of all numbers. 

There's a distinction though between the set of all sentences and the set of all numbers. The set of all sentences is /countable/ in the sense that we can count all of them if we give ourselves an /infinite/ amount of time. On the other hand, the set of all real numbers is /so large/ that even with an infinite amount of time you couldn't possibly count all of them. In fact, you can't even count all of the real numbers between 0 and 1! This means that the set of all real numbers is /uncountable/. 

The most important countable set is the set of /natural numbers/, which are formally defined as being either 0 or one plus a natural number. So the natural numbers consist of 0,1,2, etc. The natural numbers /are/ the counting numbers.

Another important uncountable set is the set of all functions that take in a natural numbewr and give you back a natural number. We won't prove that here, but rather just assume it as a fact.

A rather interesting set is the /set of all programs/ for a given programming language. Is this set countable or uncountable? A program is a finite piece of text with a finite set of symbols. Again, we'll skip the proof but it turns out to be true that if you're dealing with /finite/ texts over a /finite/ alphabet then there's at most a /countable/ number of texts. A countable number of texts means a countable number of /programs/. A countable number of programs can't possibly encode an /uncountable/ number of functions.

This means that of all of the mathematically definable functions from the natural numbers to the natural numbers, a programming language can only describe at most a countable fraction of these functions. 

What does this mean for computer science and how it relates to programming? It means that there's an absurdly infinite number of things mathematics that cannot be described as computations. So even though a lot of the processes that we deal with every day make sense as computations, most of the things mathematicians do every day are much harder to describe computably. 

The essential thing to take from this digression is that there's a theoretical /reason/ why writing the right program to solve a problem can be very difficult. The most obvious way to try and solve a problem might not even be computable.
** Informal Descriptions and Algorithms
   Programming-in-itself can be an enjoyable exercise, but we write code in order to solve a problem. The first part of solving any problem is going to be describe our solution informally, in words, rather than jumping straight into code.

   For example, if our problem is how to put a bookcase into alphabetical order an informal description might sound something like 
#+BEGIN_QUOTE
First, remove all the books from the book shelf and put them in piles corresponding to the first letter of the last name of the author. Sort each pile individually into alphabetical order, then put the piles back on the bookshelf in the proper order.
#+END_QUOTE
Now, this description leaves out some details but it's a rough description of what to do and how to do it, enough so that later when we're sorting data in a program we'll /implement/ this informal description fairly directly.

There's a couple of reasons why it's best to start with describing the problem in words. First, to clarify to yourself how you want to solve the problem. It's easy to get lost in the woods when you're working on a large program if you're figuring out the details as you go. If you have the big picture in front of you and you've already thought the solution through, you're far less likely to go back to the drawing board in the middle of coding. 

Second, an informal description is more portable. You, or more likely someone else, can implement your solution in a different programming language. Even though programming languages can look very different from each other they all have their own way of describing how to perform computation. 

(insert diagram of one to many to one relationship here)

These informal descriptions of solutions are generally called "algorithms" and the ability to clearly write down an algorithm in an understandable way is a valued skill in both academic and commercial programming.

** A First Problem
   The very first task we're going try to solve is to ask the user for the title of a book and printing it back out in proper title case. 

   Our informal description of our solution is 
#+BEGIN_QUOTE
First we prompt the user for the name of a book. If they didn't enter a title, then we should print "goodbye" and end the program, otherwise we should convert the book into title case. To convert the book into title case, we need to check each letter and, if it starts a word that isn't article, preposition, or conjunction then we capitalize it. When we reach the end of the title we print it out and say "goodbye" to the user.
#+END_QUOTE

The next several sections are going to outline all the syntax we need in order to implement this algorithm. We'll introduce a number of smaller problems to illustrate how each piece of syntax and we'll tie all of it together by showing how we translate the above description into an actual program.
** First Steps
 The /very/ first piece of syntax we're going to introduce in Javascript is how to print out values within a program. 

 Write the following lines of code in a file called ~FirstSteps.js~.
 #+BEGIN_SRC js :exports code :results output :tangle FirstSteps.js
   console.log(10);
   console.log(100);
   console.log(300);
 #+END_SRC

 #+RESULTS:
 : 10
 : 100
 : 300

If you run this file using the following command you should see the output indicated.
#+BEGIN_SRC sh :exports both :results output
  node FirstSteps.js
#+END_SRC

#+RESULTS:
: 10
: 100
: 300

We need to discuss what's happened here. First off, we've introduced the syntax ~console.log(v)~, whose semantics is to print out to the console the value of its argument, this means that it prints out the result of Javascript evaluating ~v~ and not just the literal syntax of ~v~ as we'll see shortly. This will be very useful for us in testing out our programs and checking that we understand the semantics of our constructs.

The second piece of syntax we've implicitly introduced is the /semi-colon/ and the /line break/. Javascript separates its syntax into /statements/ and /expressions/. We'll make more clear what the distinction between these two, but at first let's just say that statements are things that are separated by lines and expressions are things that can be fed as arguments. So, for example, ~10~ and ~console.log(10)~ are expressions but ~console.log(10);~ is a statement. We can run a series of statements by separting them as new lines in the program. Some other languages that use semicolons are Java, C, C++, C#, and PHP. The use of semicolons is one of those historic conventions that's good for the person writing the implementation of the programming language, but less so for the programmers who need to work in that language. As such, Python doesn't use the semicolon convention and instead just uses linebreaks and indentation to naturally divide code. Going back to our analogy about recipes, think of an expression as a thing like "a cup of flour" or "six onions" but a /statement/ is a step in the recipe such as "sautee six onions until soft". So in the example above each line that has ~console.log(v);~ in it is a separate statement that is executed in order, just like you'd execute the steps of a recipe in order. 

Now that we have a way to print out values and are starting to understand the difference between expressions and statements, we can start introducing operations on numbers as a first step. We have in Python all the basic operations you're familiar with, including +,*, and -. We can see how they work in the following code, which you can copy into a file called ArithmeticExpressions.js

#+BEGIN_SRC js :exports code :results output  :tangle ArithmeticExpressions.js
  console.log(10 + 10)
  console.log(10 * 10)
  console.log(10 - 10)
  console.log(10 / 10)
#+END_SRC

#+RESULTS:
: 20
: 100
: 0
: 1

If you run this code with the following snippet then you should see the same results as below.

#+BEGIN_SRC sh :exports both :results output
  node ArithmeticExpressions.js
#+END_SRC

#+RESULTS:
: 20
: 100
: 0
: 1

It's important to note that the number that's printed out is the /result/ of the expression that's passed into the ~console.log~. 
*** Evaluating Code By Hand
    One of the themes of this book is going to be how to take a pen and paper and evaluate your code. This might seem like an odd skill to learn, but it's useful for getting rid of some of the "magic" feeling that comes with writing code for the first time. If you're not sure how a piece of code works, it's really helpful to be able to sit down and go through it step-by-step for yourself. 

So far, we've seen three pieces of syntax: 
    1. the ability to print using ~console.log~
    2. numbers represented using the normal decimal representation
    3. basic arithmetic operations on numbers
and two classes of syntax
    1. expressions
    2. statements

First, as we've aluded there's a notion of *values*. What makes an expression an expression is that it returns a *value* when evaluated. Statements, on the other hand, are useful for their control flow. When we coerce an expression into being a statement via ~expression;~ what we are doing is inherently throwing away the value returned by the expression. This is useful for things like ~console.log~ where we're not actually returning anything particularly useful and just using the /side effects/ of the expression. Side effects are all the ways an expression can affect the world other than through the value they return. So far the only side-effect we've seen is the ability to print output. We'll point out other side-effects as we're introduced to them.

Now, we take the pieces of syntax we've seen so far in order:
  1. ~console.log(e)~ is evaluated by first evaluating ~e~ until it yields a value ~v~ and then writing that value down under a column labeled "Output" on your paper
  2. numbers are evaluated simply: a number ~n~ written in decimal notation evaluates to itself, i.e. numbers are already values
  3. basic arithmetic operations are evaluated as the normal arithmetic rules you've learned, i.e. ~+~ is addition, ~-~ is substraction etc.

** Basic Types
We've informally used numbers and arithmetic in the previous section, but now we need to describe what /kinds/ of data that we can use in Javascript. We'll start with the simplest of all kinds of data. 
*** Strings
     Even though it's fairly transparent, words themselves are a kind of data we constantly deal with: our texts, our emails, our social media posts are all text-as-data that our computers interact with.
     
     Given that our programs are also /text/, we need some way to distinguish between text-as-data and text-as-instructions for the computer. Text-as-data are called /strings/. We denote strings with quotation marks, either "like this" or 'possibly like this'. This mimics what we do in English all the time: there's a difference between this sentence and "this sentence". It's like the old playground joke "Say 'Mississippi five times fast'" to which you're supposed to respond "Mississippi five times fast". In fact, Javascript allows us to do exactly that. If we want to include quotation marks within a string we can either "do something 'like this'" or 'maybe something "like this"'.
**** Evaluation
     Strings, like all primitive data evaluate to themselves. You can test this yourself by starting up the Node command line and typing a string, like in the following example
     #+BEGIN_EXAMPLE
     clarissa@ramiel ~ $ node
     > "this is a string"
     'this is a string'
     > 'this is also a string'
     'this is also a string'
     > 'this is a string "with" quotations'
     'this is a string "with" quotations'
     > 
     #+END_EXAMPLE

**** Operations
     There's a number of operations on strings in JavaScript. The first one involves connecting strings together, called concatenation. 
*** Numbers
**** Real life examples and analogues
**** Syntax
**** Evaluation
**** Operations
*** Booleans
**** Real life examples and analogues
**** Syntax
**** Evaluation
**** Operations
** Variables
   Imagine you're telling a story but you want a placeholder for the actual name of the person in the story. You might say something like "So a friend of mine, call her Sandra, used to be a lion groomer"
*** Variables-as-containers

** Control Flow
   (We need to explain how control flow constructs are the "verbs" of a programming language, they describe what to do with the data. There's three classes of control flow for the purposes of teaching. 

   1. Branching: choosing between actions 
   2. Iteration: doing things repeatedly
   3. Calling functions: switching context to a different piece of code and then coming back to where you were

   Now I was a little wary about calling functions a control flow construct, but they really are because they're changing the execution context and running code that isn't the next literal line in the textual representation. 

   I might end up changing my mind a bit on this at some point, but I think it's a reasonable approximation
)
*** If-statements
**** Real life examples and analogues
**** Syntax
**** Evaluation
*** Iteration
**** for-statements
***** Real life examples and analogues
***** Syntax
***** Evaluation
**** while-statements
***** Real life examples and analogues
***** Syntax
***** Evaluation
*** Functions and Function Calls
    (we need to talk about how functions are reified programs, but without really saying something that opaque. the idea is that functions can be called within the language the same way we can call programs outside the language)
**** Declaring functions
**** Naming functions
**** Calling functions
**** Function scope
** Project 1
** Closures
   (the point of this section is to cover just a few of the ways lambdas + mutable state lead to really powerful abstractions)
*** Closures provide stateful programming
*** Closures provide privacy
*** Closures can mimick modules
** Objects
*** Objects-as-Containers
    (objects can be used to group data together for being passed around, like for JSON or returning multiple values or as a hash-table etc. )
*** Objects-for-Organizing
*** this
** ADTs and Projects
*** Importance of Abstraction
*** Lists and Doubly Linked Lists
*** Stacks
*** Queues
*** Trees

** Testing and Error handling
*** Checking types
    (An important way to deal with preventing mistakes is to ensure that you're getting the right kind of data)
*** Writing specifications
    (we should cover how to define what your code does before you even get started on writing it, the things to consider about types and errors and what contracts it should enforce. Even just the concept of contracts in general for programming)
*** Testing behavior
    (How to write unit tests and describe what your code is supposed to do. Probably include a couple of different libraries for doing this or making a simple one ourselves. In fact, that's a decent project for this section I think: have them use unit testing libraries and then have a walkthrough for writing their own, with optional features and the like)
    
* Advanced Programming Concepts
** Advanced Abstract Data Types
*** Self-balancing Trees
**** Red-Black
**** 2-3 Trees
*** Heaps
** Reading Code 
   (In this section we need to discuss how to actually read code and the strategies and exercises for that. 

   I think my own strategies for this are to skim the code and take notes on it. First, identity the main features of the code: what's the first thing called and what does it call within/after that, then take notes on all the other functions involved in that initial setup and take notes on their signatures and what they appear to do, then look at how the functions are called and the names of variables for clues etc. Whenever you really can't understand what something does, attempt to evaluate pieces of it by hand)
** Modules
* Classic Programming Problems
** Sorting
** Searching
** Graph Problems
   (there's a million and one problems that come down to graph traversal and manipulation, and any two or three of them would be great for teaching how to deal with algorithms and think of coding)
* Indices
** Be The Interpreter
*** General Rules and Setup for Interpreting a Program
    First, mark down a box labeled "current line". Every step you take, make a note of what line you're on.

    You'll start at the first line of the program and, unless some rule specifies otherwise, go to the /next/ line of code after you're finished with each line.

    Also make a special section labled "output", which you'll use every time something is written to the console by the program.

    If a line of code is an expression *only*, evaluate the expression as normal then *throw away* the return value of the expression.
*** Variable declaration
    Look at your program. For all of the instances you see of ~var name~ or ~var name = expression~ (that isn't in the body of a function (and if you haven't seen functions yet, don't worry)), make a table that looks like

    | name1 | name2 | name3 | name4 | ... |
    |       |       |       |       |     | 

It should have one column for each variable name. 

You don't actually fill anything *in* to start, instead if there's a ~= expression~ portion of the variable declaration you wait until the line in question is reached before filling in the entry in the table according to the rules of the assignment expression.
*** Expressions
    If an *expression* is the only thing on the line, evaluate the expression according to the appropriate rules for that expression.
**** Arithmetic
     Numbers evaluate to themselves. Arithmetic operations evaluate exactly according to their  them to: ~+~ is addition, ~-~ is subtraction, etc.
**** Strings
     Strings evaluate to themselves. The ~+~ operator "concatenates" two strings together.
**** Booleans
     ~true~ evaluates to ~true~, ~false~ evaluates to ~false~. 

     The boolean operator ~!~ takes an expression. Evaluate ~! exp~ by first evaluating the expression ~exp~. If it returns a truthy value, then return ~false~. If it returns a falsy value, then return ~true~.

     The short-circuiting operators ~&&~ and ~||~ have special rules. ~exp1 && exp2~ is evaluated by first evaluating ~exp1~, if it is truthy then evaluate ~exp2~ and return its value. If it is falsy, then return the value of ~exp1~.

     ~exp1 || exp2~ is evaluated by first evaluating ~exp1~. If it is truthy then return the value of ~exp1~. If it is falsy then evaluate ~exp2~ and return its value.

     As a reminder, falsy values are ~NaN~, ~null~, ~undefined~, ~0~, ~""~, and ~false~. Everything else is truthy.
**** Assignment
     Assignment is always of the form ~name = expression~. First, you evaluate the expression based on the kind of expression it is, then fill whatever value it returns *into* the appropriate entry in the table.
     
     The value you wrote into the table is also the value returned by the expression.

**** Output to console
     For purposes of "being the interpreter", we're going to treat the function ~console.log~ as a special operation. When you see an expression of the form ~console.log(exp)~, evaluate the expresion that is the argument, then write the value in the output column you've set aside. As an expression, ~console.log~ returns ~undefined~. 
**** typeof
     The ~typeof~ operator takes an /expression/ as an argument. Evaluate this expression is and return, as a string, the type of the value returned according to the following rules
     + numbers return "number"
       + this includes ~NaN~ and ~Infinity~
     + strings return "string"
     + undefined returns "undefined"
     + objects return "object"
     + booleans return "boolean"
**** Variables resolution
     To evaluate a variable, you have to first consider where the variable's ~var~ statement is and you then you examine the corresponding table that you made. If there is an overlap in names between two tables that are both visible from a point in the code, precedence goes to the more recently created table.
**** Function calls
     A function is called when it is passed zero or more arguments. For example, ~fun()~, ~fun(1)~, ~fun(1,2)~, etc. are all valid function calls.

     A function call is evaluated by:
     1) substituting the passed in values for the arguments of the function, which means everywhere the formal argument was seen in the function body, rewrite it to be the corresponding value
     2) evaluate the body like you would a new program
	1) make a variable table
	2) evaluate each statement sequentially
	3) if there is a return statement, then *stop* executing the function, go back to the point of where the function was called and hand back the value of the expression passed to the ~return~
	4) if there is no return statement by the end of the function, return ~undefined~

***** A caveat on variable tables for functions
      After exiting the function, if there is nothing else that can reference the function's local variable table, then you may erase the table.

      If, on the other hand, that table is still visible to some entity in the program, you may *not* erase it and must keep the variable table in play.
*** Object specific expressions
**** General object layout
  An object is represented as a table a list of pairs of 
     + a property name
     + the value corresponding to the property

**** Objects and variables
     An important note about variables and objects. A variable never holds a literal object. Instead, what the variable contains is an "arrow" that points to the object. The "value" of an object is, then, simply the pointer rather than the object itself.

     The implication of this is that there's no 
    
**** Object creation with new
     Objects can be created using the ~new Constr()~ syntax. This is evaluated by
     1. creating a new object
     2. setting the ~.constructor~ property to the constructor function
     3. running the constructor function with ~this~ bound to the new object
     4. returning *a pointer to* the new object after the constructor function finishes running

     An object created with the ~{}~ or ~{ prop : val, prop : val, ...}~ syntax is equivalent to an object created using ~new Object()~ that then has the corresponding properties, if any, set.
**** Object property access and assignment
     An object's properties can be accessed through two methods: the "dot" syntax ~obj.prop~ or the "array" syntax ~obj["prop"]~. These are evaluated identically, the only distinction is the names that are allowed to be used for the properties: the array syntax is far more permissive with allowed names. 

     You evaluate property access by looking up the value of the property in the object and returning it. If the property isn't in the table corresponding to the object, first check the prototype of the constructor of the object. If the property isn't in the prototype or the prototype's prototype etc., then return undefined. When searching for a property, the first place you find it takes precedence and you return with *that value* immediately and do not continue searching up the prototype tree.

     You evaluate property *assignment* by first evaluating the expression to the right of the ~=~ and putting that value into the table corresponding to the object, making a new space for the property if there isn't already one in the object.
**** this
     The statement ~this~ acts like a variable with special evaluation rules. There's two different ways in which ~this~ can be used
     1) in the constructor of an object
     2) in a function to be called *by* an object

In the first case, when ~new Cons()~ is called to make a new object using the constructor ~Cons~, ~this~ is a reference to the fresh object that is being constructed. See also the section on object creation.

In the second case, when a function is called *as a method*, ~this~ points to the parent object. 

If ~this~ is encountered outside of these two cases, then it resolves to the "global object" of the program.
*** For loops
    A basic for loop has the form
    #+BEGIN_SRC js :exports code
      for (initialization; condition_for_continuing; next_step){
          statement1;
          statement2;
          statement3;
          ...
      }
    #+END_SRC
It's not *strictly* required, but you should make the "initialization" code only be of the form ~var name = exp~ or ~name = exp~. The condition for continuing the loop should be an expression that returns a boolean. The next step slot should be an assignment expression that modifies the variable named in the initialization.

The rule is that you 
   1) execute the code in the "initialization" slot
   2) evaluate the condition for continuing
      1) if it is truthy, go to step (3)
      2) if it falsey, jump to the line of code *after* the end of the for loop
   3) execute the statements in the for loop
   4) execute the code in the "next step" part of the for loop
   5) go to step (2)
*** While loops
    A while loop has the form
    #+BEGIN_SRC js :exports code
      while (condition){
          statement1;
          statement2;
          statement3;
          ...
      }
    #+END_SRC
The rule is that you
   1) evaluate the condition
      1) if it is truthy, go to step (2)
      2) if it is falsey, jump to the line of code *after* the end of the while loop
   2) execute the statements in the while loop
   3) go to step (1)

*** If statements
    If statements have the basic form
    #+BEGIN_SRC js :exports code
      if (condition){
          statement1;
          statement2;
          ...
      }
      else {
          morestatement1;
          morestatement2;
          morestatement3;
      }
    #+END_SRC
    The rule for them is that you

    1) evaluate the condition
       1) if it is truthy, perform the statements listed between the braces of the "if"
       2) if it is falsy, perform the statements listed between the braces of the "else"
    

The other form of if-statement is to leave out the ~else~ branch. In this case, our rule reads

    1) evaluate the condition
       1) if it is truthy, perform the statements listed between the braces of the "if"
       2) if it is falsy, do nothing
  
*** Function declarations
    There are two function declarations. There is the *expression* form which has the following syntax 
    #+BEGIN_SRC js :exports code
      function (arg1, arg2, ...) {
          statement1;
          statement2;
          statement3;
      }
    #+END_SRC
 This evaluates to a function value, which in our pen and paper we'll represent as a box that
    + contains the list of arguments to the function
    + the lines of code for the body of the function
    + an arrow pointing to the variable table within which the function was defined (this is important for calling functions!)

The second kind of function declaration, which is a *statement*, is the named function declaration, which has the following syntax.
    #+BEGIN_SRC js :exports code
      function name (arg1,arg2,arg3) {
          statement1;
          statement2;
          statement3;
      }
    #+END_SRC

You evaluate this by treating it as equivalent to 
#+BEGIN_SRC js :exports code
  var name = function (...){
     ...
  };
#+END_SRC

** The Lambda Calculus
*** Universal Computation
*** The Core Language
*** Data in the Lambda Calculus
*** An Interpeter in Javascript
* Footnotes

[fn:1] I find it rather unfortunate that the word "variable" has these two, very different, meanings in computer science since variables-as-containers could probably be more accurately called "references", since they are special names that *refer* to a location in memory. 


