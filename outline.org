* Outlining
** An issue of audience
   So one of the questions I don't know if I've entirely answered is /who the heck is this book for/

   The idea is that this should be for someone who has maybe a middle school math background and not necessarily any programming experience. What does that /mean/, though, I'm asking myself.

   One of the things I'm wondering about is what /skills/ I actually want someone to come out of this book with.

   So, obviously, I think one of the main things is that they should have a basic understanding of JavaScript. For example, we need to ensure that they understand concepts like iteration, variables, functions, scope etc. 

   That's not all, though. What I want students to come away with is a general sense of computation. I'd been initially thinking of trying to run the book as a polyglot text, but I think at this point I've convinced myself that's not really a good idea. Why? Because I think that it will just reduce us to a lowest common denominator text. One where we might be just including only things that are easily expressed in other languages.

   Of course, what we *could* do is include little snippets explaining how different languages can express some of the same concepts. The more I'm thinking about it the more I think this might be a good idea. I could format it cleverly by having something like little inset segments that show how different languages will actually work.

   So, for example, if we're talking about how to define functions we could have something like we're describing how functions work in JavaScript and then we have a block called "In other languages" and we have the syntax for declaring a function in, I don't know, Java, Ruby, and Clojure. We can even do a thing of changing /which/ languages we show in order to only include which languages are relevant rather than forcing ourselves into the least-common-denominator approach that I really was worried about. 

   Further examples:
   How objects work in Ruby, Java, and...Smalltalk?
   Iteration in Ruby (using maps and blocks all that) and Python
   Reading from the console vs. printing to the console in Ruby and Pythong 
   Modules and namespaces in 
   Closures and higher order functions in Ruby and C# and clojure
   Code flexability and metaprogramming in multiple languages
   
These kinds of things would demonstrate the idea that whatever we're doing isn't /just/ located to a specific language but is, instead, a part of how the fundamental concepts of computation are expressed in any language. Again, these are just like human languages, where the same things can be expressed in different ways but they're all expressing the same fundamental, universal, notion of computation that is separate from all of these notions of specific language and syntax.

So, stepping back a little bit the question is then /what do I want students to come out of this book knowing/ and the question is still hazier than it probably should be. 

For starters, we want them to know the basics of javascript-the-good-parts. What I mean is that I really just want to cover the parts of the language that show up in Crockford's book plus some extras that come from more modern standards. Like, for example, arrow functions and modules. For the most part, I'm going to try and leave out as many unnecessary edges of JavaScript as possible. This isn't a standard nor a definition of the language. I don't need to pretend it is. This is a dang book about programming and computer science.

Next, I want to convey that the basic /structure/ of programming looks the same no matter what language you're using. There's always a way to do the same set of actions multiple times. There's always a way to branch in your code. There's always a way to control the visibility of code. There's always a way to reify sequences of code into functions. There's always a way to store data and control state. All of these things exist in every programming language, no matter what. Some languages may make tasks easier in some cases and harder than others. That's okay and ends up being a personal preference to everyone. I want to convey my own extremely blase attitude about what makes a good language, because fundamentally /I don't care/ and I don't think other people should particularly care either unless there is *a very specific use case*.

Beyond those general lessons, what skills do I want to teach?

I want to teach soft skills about reading and writing code, about understanding code and writing specifications. Even having exercises on all of those skills. Beyond that, I also want to explain how to test code and how to have some confidence in how it works. I want to give readers the ability to understand code and check what it does in small cases by simply trying it out by hand in order to get intuition. I know that my ability to do that partly comes from using languages like Haskell for most of my life, but it's not /entirely/ because of that. I think evaluating code by hand is just a good way to get intution. 

This goes back to my long standing rants that we should teach programming more like we teach arithmetic than like we teach languages. We should teach these things in terms of how they operate, how they behave, rather than by just explaining "this is the word that's used here" style. Natural languages are weird and irregular because they evolved, for lack of a better word, /naturally/. Programming languages are *designed*. As *designed* languages, there are reasons for why everything is there the way it is: because someone chose it! Now, that doesn't mean there's necessarily a /good/ reason for it, but it does mean there's some kind of reason. There's "I'm lazy in how I write my parser". There's "this is how C did it". There's "I want my syntax to be simply for metaprogramming". We shuld never treat programming languages as though they simply exist and don't involve so many choices about how every piece of it works. Every piece of the language has some kind use, and we should teach the syntax by its semantics. This is something I've shamefully /not/ done in some of my intro to programming classes, but I still think it's a good idea. Present the computational idea, then the way it's expressed. 

Stepping back for a few notches here: 
  So we've argued that we need to present a combination of "soft" and "hard" skills. Why? Why try and do that in just one book? Well, I'd argue because I want to provide a book that will demystify. That might be one of unifying themes of the text: to make technology feel less mysterious. Maybe rather than trying to make a massively comprehensive text, instead I need to just go with covering what's needed to make it feel /less mysterious/. See, my problem lately has been that I've been feeling like my plans for the book are just growing and growing and growing. It's been going from a small and reasonable book to being a book that's trying to cover everything possible. 

So, instead, let's go back to the big picture: we want to demystify programming. We want to make it clear how to write code and how to read code and what it all means. We want to teach /a/ programming language in a way that makes it very clear how to use /any/ programming language. We also want to demystify programming in the real world by showing how things like web APIs and file formats work. We want to explain how the technology works on some level. 

This helps me think a little better. Maybe the reason why things like classic CS problems like searching and sorting and path-finding in graphs didn't feel like they fit very well was because, well, they *didn't*. They don't fit into a book that's trying to teach programming on some very fundamental level and attempting to demystify how all of this works. On the other hand, chapters about some of the theory of computer science would absolutely fit into this because they're about what programming /is/.

I think cutting out any topic that isn't about making programming /clear/ would help a lot with trying to make my outline not stink. So far I've been so frustrated by every attempt to outline because it keeps turning into something else. Something I don't want. 

So let's try this outline /yet again/

** Outline again
*** Exercise styles
    Okay, one of the things that's going to be different about this book versus most books on computer science or programming is a plethora of problems of varying size. There'll be smaller exercises as well as larger projects. 

    So what kinds of exercises are we going to have? 

    First, we'll have multiple choice questions where it'll be showing an example of code or a concept and ask some question about it. Multiple choice questions, when done right, can actually force you to think really hard about how things work. They're fast but meaningful.

    Next, we'll have "fill in the blank" questions where you'll be dealing with partial listings of code and are given some kind of data about what happens when the code is run. Once you have that the question is to fill in all of the blanks in the code that are needed to make that happen. These will probably also be some of the easier exercises, just hammering home the concepts so that you can get more comfortable with the syntax and concepts of the language. 

    Third, there's going to be small programming exercises where we'll be asking them to solve a particular programming problem with certain parameters around it. 

    I think combining a few different styles of exercise would be useful for learning. Mostly because good exercises are always the part you remember from math and science texts. Like, I still remember the problem of figuring out the time it takes a chain with a given density \delta to fall off a ledge if the ledge was frictionless. I remember problems like that from homework even ten fifteen years later. Why? Because it's the homework questions and the test questions where everything would end up clicking in my head. So that being said I think it'd be really great to *finally* write a CS text that does something similar. I mean, the closest I've ever seen was SICP but SICP isn't very accessible to people without a heavy math background. As I've said elsewhere, I think targeting higher level audiences is cheating for an intro textbook

*** Introduction
**** What is programming?
     One thing I keep debating on is just *how* much we should be talking about 
**** Why learn it?
**** What are programming languages?
**** Why JavaScript
**** Syntax vs. semantics
     The general concept of syntax vs. semantics and how every bit of the language has meaning in terms of data and computation.
**** Specifications
     So we should explain how we want to /describe/ the programs we want to write. We want to establish a basic pattern of keywords for how to describe specifications. One of the things that we'll be introducing are keywords that correspond to all of the computational concepts.
*** JavaScript and Basic Computation
**** Arithmetic
     The basic concepts of numbers. Show that it's just like arithmetic in math class. Special weird numbers like NaN and Infinity. How those work.

     Explain about evaluating code by hand by piggybacking on things like experience with arithmetic. 
***** Numbers
***** Operators
***** Special numbers
****** NaN
****** Infinity
**** Sequencing
     The need to sequence code into multiple steps is obvious. This just needs to be s short section showing how to evaluate code by hand.

     We need to explain the difference between sequences and statements.
**** Storing data: variables
     Holding onto data. Variables as general pronouns. Variables as storage. The concept of scope and variable tables in handwritten.

     We have some simple exercises that do things like present a variable table and ask you to write code that will create that table. 
**** Functions
     Explain the need for functions in terms of reifying code. That's not the term I would use, but the idea is that we want to save code and be able to use it later. 

     We need to explain how to evaluate functions by hand. We'll explain how they introduce their own variable tables when they start and, if those tables aren't being referenced, they disappear when the function exits. 
**** Branching
     Next, we need to talk about how to do branching and if statements. If-statements, along with their else variants, are the basic operations of branching. We can explain informally what it means to do branching in terms of any form of direction. If it's raining, use an umbrella and things like that. We can explain boolean true and false. We can tie that into the notion of expressions
***** Booleans
***** Boolean operators
***** Arithmetic comparisons
***** If-statements
**** Iteration
     Here we need to explain that it's necessary to take blocks of code and do them multiple times. So what we have are several basic concepts for how to do that. So there's definite iteration, which is for-loops, which can be described as "iteration where you knew how many times you want to do it" and there's also /indefinite/ iteration which is when you don't know how many times you'll be going but you'll know when you're done.

     We can explain this in terms of instructions we follow in real life all the time. 

     We can explain definite iteration in terms of walking down a number of blocks. Indefinite iteration is more like "turn left at the blue house on the corner". Running functions is more like having a set recipe that you know how to execute and being able to call it. Or maybe something like "tying your shoes". It's so rote that you can just treat it as a packaged operation rather than a series of steps that has to be described each time. To do something multiple times with a function, that's something like /recursion/. In order to actually do recursion we need to have branching first, so that's an obvious dependency that we have in the game order. 

     Where do we explain mapping though? Because it's really not obvious where that should be introduced. 

     One possibility is to just put it with iteration /here/ because it's yet another form of iteration, but I don't know if that's helpful. We might run into an issue of explaining Too Many Ways to do just one thing and losing the plot early on in the text. 

     So why don't we do a "revisiting iteration" maybe a bit later on when we're doing more advanced coding? By now we should hopefully be no more than the first 20-30 pages of the text. Enough that you can have gotten your rough introduction in a single sitting. After iteration is probably time for our first project. Oh, I suppose another reason for having an /advanced iteration/ section is that we just don't have the data structures yet to talk about mappings. We have to introduce arrays first.

     For recursion, I think all we want to try and do is explain that you can use the simple notion of functions calling themselves with changing arguments as a way of simply expressing how iteration is done. I personally don't think there's really a need to talk about blowing the stack and things like that in a modern language. I know that JavaScript doesn't have (yet?) tail-call optimization but that's also a topic that I think isn't worth mentioning in this text. Once you've had solid fundamentals then I think you can absorb it just fine when you need it. Although I'm questioning myself a bit now and wondering if maybe it should be an appendix on how functions are called and all of that. 

     So back to the matter at hand. Recursion is useful to explain because it's helpful for having iteration go across the /structure/ of the data. Rigid iteration constructs are too linear. The non-linear call structure is what let's you do cute and interesting things. 
***** Definite iteration
***** Indefinite iteration
***** Functions and recursion
**** Aggregate data
     There are two basic forms of aggregate data in JavaScript. There's objects and there's arrays. Arrays in Javascript function as lists. 
***** Arrays
      The things we want to cover in terms of arrays are the basic interface for adding and removing elements, modifying elements, etc.
      
      We want to get across the pattern of iterating over them. For each form of data we should introduce the way it's used. 

      So we've introduced booleans/if-statements as a pair, we can explain that the normal for-loop "definite iteration" is the corresponding operation on numbers, and now we can show the for-loop version that corresponds to using arrays.

      After that, there's really not much to say about arrays other than ensuring it's clear that we can have arrays of arrays or indeed of any data type you want
***** Objects
      Now there's a lot to talk about with objects here. There's an explanation of /methods/. There's an explanation of =this=, there's an explanation of /constructors/. There's just a ton of material that needs to be covered in all of this. 

      I don't /really/ want to introduce it in stages but I think explaining the need for constructors and prototypes and all of that may take us out of the initial scope of using objects. Prototypes are going to belong in our sections on how to organize and reuse code, more than anything else. 

      The first way of introducing objects should maybe be focused on them as key/value pairs and on the methods they can have and basic constructor/this manipulation.

      We can delay the sections on hiding data with closures and things like that until later, once we're talking about the concept of organizing data and modularity. Closures + objects are a great little namespace hack and one that controls private data. 
**** Organizing data
     Here's where we should probably start talking about ideas like how to do things like code hiding and controlling what's visible. We should also be talking about prototypes and how they can be used to provide common interfaces to code. 

     Once we're talking about prototyping then we need to deal with more details about how /this/ works and all of that. By the outline as it stands we've spent very little time talking about /how/ objects work. 

     We'll need to go back to constructors and talk about how
     + every object has a constructor
     + every constructor has a prototype
     + and we'll need to give the basic outline of how properties are found in objects by ascending the prototype tree

We'll need to talk about object oriented design patterns of organization. I'm mostly familiar with gang-of-four style patterns, but in order to write this section I'll try to come up with some examples based on the flexibility of the prototype model. I suppose one thing that's very true of prototypes is that they can be modified during the execution of the program, unlike the very static notion of classes that you have in something like c++ or java. 

Now, that being said you can futz with class structure in Ruby just as much (or maybe even more?) than you can with prototypes but I think the /nature/ of prototypes makes for a really easy to understand the methods of inheritance. 

IIRC the right way to do things like class variables in JavaScript is as properties of the prototype. 

Is it here or later when we should do the whole "closures can simulate objects" thing. I'm not sure how much detail to go into on that one, though. There's the cute examples at the beginning of Let over Lambda on the connection between objects and closures. I think Graham's book on ANSI common lisp also had some examples on this topic, despite some of the idiosynractic code that I know the book has. 

This is probably a good section to have a number of puzzles in terms of how to write code to achieve certain results. So to give, say, some form of trace of how the program should execute and then partial code and ask everyone to fill in what the code should be. We can do this to demonstrate what it means for properties to be private or for there to be class methods and properties and things like that. 

*** Connecting to the real world
    So as a part of clarifying the mysticism around programming, we should spend some time talking about how your isolated programs interact with systems in the real world. 

    For example, /file formats/. That's actually kind of a cool topic. Way cooler than it might seem. The point is that structured data is how programs can talk to each other. So, for example, we can talk about STL for 3D printers. We can talk about SVG and how it's something programmable. We can talk about cvs as a way of writing and storing data that can  be used in other contexts. 

    We also want to talk about things like APIs for websites, so that we can give an example of how to write code that will interact with a site.

    This means, though, that we'll need to introduce the topics of requests work over the internet. One of the big elements there is going to be HTTP and how it works. So we'll cover the various request types and how the handshake works in order to talk to a website. We'll cover the idea of HTTP being a stateless protocol and how to the typical notion of api-keys or authorization tokens works. We can come up with some cute examples of programs that, say, using twitter or tumblr's api to put together some kind of data about slices of social media as graphs or, say, what the most popular posts in your own friend's list is. 

    There's also things like flickr's api (https://www.flickr.com/services/api/) which I've heard good things about. No matter what, we need some *cute* examples of using website APIs. 

    One question I'm torn on is how much time to really spend on communication over the internet. It's a deep topic and we could go arbitrarily deep onto this. We could cover the level of sockets and tcp vs. udp, or we could just start at a high level Node interface for making these connections.
     
    Mostly, the goal here is to always keep things from being /more/ mystified. We need to make the technology if not completely elcudiated then at least no longer feel magical. We could include a little appendix that goes into more detail about how these connections across the internet work under the hood, but let the main body of the text be more streamlined.

    There's probably a stream and/or request handling library that's as simple as Python's requests library or their urllib2 library. I'll just have to figure that out before writing this section, obviously.
**** File formats
**** Making programs talk to websites
***** HTTP
***** The hardware that makes the internet tick
***** Node libraries for HTTP requests
***** Website API
*** Reading and writing code
    This is, I think, probably one of the more unique sections we'll be including in the text. I'll need to come up with some general techniques and tips, though, and then test them out myself. First off, I think a good technique is just to get a quick survey of what important functions are in the code and then starting to put together a top-down map of what code does what job and /then/ diving into the functions and figuring out how the algorithms are conveyed.

    Things to look for are for-loops, which are frequently for traversing data structures, while-loops are often where serious logic happens since they tend to be used for anything from event-polling, to main bodies of algorithms, or interactive code.
    
*** Understanding algorithms
    I think there should actually be a section on understanding classic problems for the purpose of formulating /how/ we come up with algorithms and how they work. Now, didn't we say that we shouldn't be focusing so much on classic CS problems? Yes, and I still stand by that. Rather than systematically doing old problems like the books I learned from, what I think would be a lot better is picking truly /interesting/ problems and examples of how data is structured. Like /graphs/. Graphs and how we represent them affects how all of our algorithms work and their computational complexity. 

    Yes, I do think we need to spend some time on big-O notation and about time/space usage. It's not /that/ huge of a topic for an intro book, but we could actually iteratively go through trying to solve some problems like connectedness and discuss how representations of data affect how efficient our algorithms can be. I mean you might think "hey, let's represent a graph as a generalized linked list" but it doesn't actually work like that efficiently. 

    We can talk about memoization and dynamic programming. We can talk about tricks to make your code more efficient and the kinds of things that would be good practice for understanding algorithms. We don't want to /teach/ a class on algorithms, which is a just massive task, but we want to give an understanding on how you representation of data structures matters, how to /read pseudo code/ and translate it into different languages. Actually the more I think about it the more I think that might be a good idea. We can sit there and go through some simple problems like, say, quicksort or connectedness of graphs or reversing linked lists and show the pseudo-code and how to translate that by explaining it in terms of our already established key words and things. I think this could be a really useful way of getting across how computation works.
**** P vs. NP
Having recently explained to kids, literally, how P vs. NP works I think it'd be pretty easy to include at least a five page section in the text about measuring the complexity of algorithms, about how what P and NP mean, about determinstic vs. non-deterministic machines, etc.

It's a cute topic and one that's rather thought provoking, even though it's /pretty/ clear that these two classes aren't the same it's still fascinating that it's such a hard thing to prove.
**** Sorting
     So I keep going back and forth about things like long elaborate discussions of sorting. I think this could also go along with the P/NP discussion because sorting algorithms are some of those things that are just /so/ simple to analyze and explain that we can use them to teach the basic concepts of structuring algorithms.

     The downside, of course, is that it's a bit far-afield in terms of teaching basic programming. 
*** Theory
    In the theory chapters of the book, which I actually think should be spread out throughout the text, we want to do something like introduce the idea that computation is a thing that exists independent of a particular design of hardware or of a particular way of describing how computation works. So, for example, we can first introduce the lambda calculus which is the simplest "programming language" as a way of describing computation.

    In the lambda calculus we can do some cute things involving representations of data, church encodings, which I think is helpful for teaching you about how data can in some sense be defined by how it's used. I mean, that's what the church encoding *is*. It's the idea that you can represent data by simply describing a function to deconstruct it. 

    Later on, once we talk about things like assembly languages and how code executes on a computer we can talk about how the Turing machine works and how to describe algorithms for it and how to simulate it. We can talk about its role in the history of computation. We can use it to talk about the complexity of algorithms and about the P vs. NP problem. We don't have to spend a lot of time on this topic, but even just 10-20 pages I think could do a lot of good for making these topics clear even without a formal CS education.

    Finally, I want a short chapter on the limits of computation. I want it to be a self-contained explanation of some of the paradoxes that show there /are/ problems that a computer can never solve. When I was teaching theoretical computer science, one of the things that was pretty hard to get across was exactly /how/ the limits of computation affect things and how you know some problems are unsolvable. I think introducing it early on in someone's programming education would probably be helpful. We can just drop this in, maybe even early on or once we start talking about real projects and algorithms, and we can get across some ideas of limitations. The most accessible version of the argument I've given involves arguing about the finiteness of programs and creating the infinite table for the diagonalization argument. There's also the liar paradox version, which could still work but for some reason I think causes a lot of consternation. Eh, now that I'm thinking about it I think it'd probably be useful to just /start/ the chapter with the liar paradox, then explain the concept of programs that can read in other programs and execute them, and then we can do a thing where we show how to write a program that executes the liar paradox. 
**** Lambda calculus
     When it comes to the lambda calculus, we need to present as a simple set of rules that are capable of expressing all of computation. 

     We can build up the basic three syntactic forms and then explain beta reduction. We don't need to worry about alpha or eta equivalence I think, just give the way of doing beta reduction and explaining how substitution works. 

     I think the easiest way to show capture avoiding substition is to give very simple examples and build up to the question of "what happens if the variable names overlap". Yes, we'll be introducing an implicit notion of alpha-equivalence for the renaming but ehhhhh. I think we don't need to give more detail than is particularly necessary.

     From there, we can start building our data structures. The simplest data structure to provide is the /boolean/ with its implicit if-statement structure. We can show the logical combinators and all of that. Then the next thing to introduce is the definite iteration of the natural numbers. We can show that the algorithmic content of natural numbers /is/ repeating actions over and over again. Heck, it just occurred to me though that the /integers/ encode the action of a case statement within iteration: you can take one action multiple times for the positive direction and a different action for the negative direction. Hmmm while that's the start of an inductive structure it needs to be hecka quotiented to actually have the structure of the integers. Really it's more like a natural number and a boolean paired together, which does---I think--- mean that it's a pair of actions and choices, an action to take if it's positive and an action to take if it's negative. Pairs are pretty simple. A pair *is* the projection functions. Lists /are/ the action on the head and the tail. 

     I think having a simple project that actually involves creating a lambda calculus interpreter would be suitable. It's not hard, it's just tricky to get the dang substitution defiition correctly in code.

     [2017-04-24 Mon] Okay, so I figured out something important. A lot of people aren't really able to just understand concepts like substitution and the kind of symbolic reasoning of that goes along with something like the lambda calculus. That means that I need to spend a lot of time working on /how/ to explain the ways to do calculations. 
***** On symbolic reasoning
      Syntax is just symbols. It's like with human languages. There isn't anything that inherently means we have to capitalize sentences or have periods or spaces between words. Heck, very old written languages were bad at this! theyjustwentonlikethisandyouhadtofigureoutwhattheymeantwherethepauseswentandwherethebeginningsmiddlesandendsofwordshappened

      Syntax is also something you may have seen from arithmetic. There's no /inherent/ meaning to the way we write things like =5 + 4=, but we /know/ from practice that =5 + 4= means that we repeatedly add =1= to =4= until it there's nothing left to add. 

      Hrmmm I'm not sure if this explanation is working, but I'll admit in this outline I'm throwing things at the wall to see if they stick. So, for example, if we explain something like the idea that you can build a term in the lambda calculus out of three syntactic forms, like 

      + function creation =\x. l=, where =x= can be any name and =l= is another lambda term
      + function application =l l=
      + variables =x= where =x= can be any name

     This may seem odd, but it's like how in arithmetic we could say: an expression is
     + =n=, where =n= is any number
     + =a1 + a2= where =a1= and =a2= are other arithmetic expressions
     + =a1 - a2= where =a1= and =a2= are other arithmetic expressions
     + =a1 / a2= where =a1= and =a2= are other arithmetic expressions
     + =a1 * a2= where =a1= and =a2= are other arithmetic expressions
     and we can add parentheses for clarity whenever is needed

     Thus, =5 + (2 + 6)=, =0 - (100 - 200)=, etc. are all arithmetic expressions. 

     So let's talk about what each of these pieces /are/

     We read =\x . l= as "lambda x dot l" where the =.= is a "Church dot" that just serves to separate the variable declarations from the body of the function. It's like in JavaScript when you have something like 
     #+BEGIN_SRC javascript :exports code
       function (x) {
           l
       }
     #+END_SRC
     Now, applying functions in the lambda calculus is written as just having a space separating the function from the argument to the function. So you can read =l1 l2= as being more like =l1(l2)= in most programming languages. Now, we don't have multiple arguments like you might be used to in most programming languages. So, instead, you have nested functions like this adding function in Python
     #+BEGIN_SRC python :exports code
       def add1(x):
           def add2(y):
               return x+y
           return add2
     #+END_SRC 

     Once we define addition in the lambda calculus we could write this as 

     =\x. \y. x+y=

     Notice that we don't have to use =return= or anything like that in the lambda calculus version and, there's no way to name functions.

     (oh crud why didn't I explain that EARLIER? well now I'll include that part here and mine it later)

     The lambda calculus is a programming language where all you have are /anonymous/, that is /unnamed/, functions. You may have already seen anonymous functions in other programming languages! Consider an anonymous function that takes a single argument that it then prints. In Ruby with blocks it looks like

     #+BEGIN_SRC ruby :exports code
       { |x| puts x}
     #+END_SRC
     or JavaScript's 
     #+BEGIN_SRC javascript :exports code
       function (x) {
           console.log(x);
       }
     #+END_SRC
     or Python's
     #+BEGIN_SRC python :exports code
       (lambda x: print(x))
     #+END_SRC
and you can see that some languages even /use/ the word "lambda" to describe these unnamed functions. 

    What's different about the lambda calculus is that it's an entire language where all you /have/ are these unnamed functions. 

    So how do you build an entire language out of just unnamed functions? Well, this means that the syntax of the language is very simple: there's function /declarations/, function /calls/, and variables.

    While originally the lambda calculus was written with the greek letter lambda (\lambda) to represent the start of a function, we'll choose syntax that looks a little more like python's lambda syntax. 

    So an anonymous function is built like =lambda x: l=, where =l= is another lambda term and =x= is the argument to the function. We'll let the syntax for /using/ a lambda term be very similar to the syntax in Church's version of the lambda calculus: =l1 l2=, where =l1= and =l2= are both lambda terms, means that you'll feed =l2= into =l1= as an argument.

    If you're used to something like JavaScript's anonymous functions, you might expect that we can write functions with multiple arguments. Not in the lambda calculus, though! We restrict ourselves to just one argument at a time. 

    When you call a function in the lambda calculus it's just like calling functions in a programming language. So in something like JavaScript if you called 

    #+BEGIN_SRC js :exports code
      function (x) {
          return 3 + x;
      }
    #+END_SRC
    and you called it with an argument of =5= then what happens in the code is
    #+BEGIN_SRC js :exports code
      function (5) {
          return 3 + 5;
      }
    #+END_SRC
    which then is going to return the number /8/. We call this /substitution/ and is *the* way that computation happens in the lambda calculus. In some sense, it's the only verb (oh that's too dorky to use in this context) of the language, the only piece of machinery. Everything in the lambda calculus is substitution. 

    So let's start doing specific examples of the lambda calculus.

    First, there's the most basic function in the lambda caculus: the /identity/ function that takes an argument and gives it right back.

    #+BEGIN_SRC python :exports code
      lambda x: x
    #+END_SRC
    
   
**** Turing machines
**** Limits of computation
  Paradoxes are hecka neat. Chaitin's constant is neater. There's a lot of things I could say about all of these topics when you get right down to it. 

*** The heart of computation

    + indefinite iteration
    + definite iteration
    + storing and retrieving information
    + reifying code
    + aggregation of data
    + abstraction/hiding of information

I know we've talked /a lot/ about organization of this book and how we need to set it up and, ultimately, I think I've decided to take a mixture of project/concept organization. The first part of the text is going to be introducing the heart of computation before jumping onto deepening these ideas with more and more projects and exercises. Part of the problem is that there aren't interesting projects that involve only a few pieces of syntax. I think my issue with structuring has been trying to interleave the projects into the early parts of the syntax.

Oh, shoot though, I do still want to include the whole keyword structure for informal descriptions of algorithms and the translation from informal to formal.

Naming parts of the algorithm means creating functions. For each or a number of times means for loops. While/Until means while loops. Describing what goes into aggregate data means that you're specifying an object. Describing what a thing should do means describing its methods.

Things like that. I don't actually think it'll be that complicated to structure projects like that. I'll just need to develop a consistent style in writing. 
** Other ideas
*** Simple computation
**** Basic arithmetic
**** Basic text and string operations
**** Variables for storage and retrieval
**** Functions as reified code
**** Functions as data
**** Booleans
**** For-loops
**** If-statements
**** An aside on writing to/reading from files
     Using the node api
**** Walkthrough project: plotting a graph of throwing a ball
     In this project we'll give a brief explanation of the project, show how to write the data to a file, and then open it in some freely available plotting engine like gnuplot and thus be able to draw a parabola.
    
     Is this too wonky or uninteresting? Mostly I'm sick of books that don't talk about /interesting/ things and just go off on "here's how we show a message!" or "here's a tiny fake video game!" and I just don't think those are terribly motivating or interesting but showing that you can actually calculate something interesting? 

     I just think it'd be nice to do a thing of each mini-project demonstrating /something/ interesting algorithmically or computationally or just in terms of real life industry

     In this case, you can write the code that simulates the effect of gravity and the initial velocity of the ball and how to approximate the laws of motion algorithmically.

     Concepts needed:
     + arithmetic
     + function definitions
     + iteration through recursion or iteration via for/while loops
     + writing to files
     + reading to files
     + running other programs
**** Walkthrough project: markov chains and generating text
     Generating text from a basis
**** Objects as collections
***** Objects are dictionaries
***** Why are they called objects
      Explain the fundamental metaphor of an /object/ having qualities, attributes, that are the core abstraction for describing an object.

      For example, a "table" with regards to trying to explain the layout of a house could be an /object/ that has a height, a width, a length, and a set of things that are sitting on it.

      If, on the other hand, we're trying to simulate furniture in terms of packing them into a moving van then we care about weight as well but don't care about anything being on it.

      Those are the kinds of thing that we need to care about when it comes to /modelling/ data. That's where the idea of object comes from in the first place
**** Constructors and prototypes
**** Walkthrough project: modifying web pages by interfacing with the DOM
***** How to load code in the browser
***** The basic DOM interface
***** Adding event handlers
**** Walkthrough project: making polygons for 3d printing
***** Introduction to the STL file format and language
 https://en.wikipedia.org/wiki/STL_(file_format)
***** How to programmatically generate a polygon
****** Representing shapes internally
****** Converting it to the representation stl wants
***** Writing it a file
***** Loading it into a free program
***** How to 3d print it
**** Walkthrough project: The SVG file format and GCode
     This can be a project that explains how to 
**** Walkthrough project: Very simple neural networks
     Teaching a neural network to classify images by...some...thing? I'm not entirely sure what would be a good thing to try: maybe a thing about noticing how many objects seem to be in an image?
**** Walkthrough project: Developing a small programming language
     Using a parsing library (that might come with the book) to read in text files in a small programming language and then evaluate the code with a simple interpreter.

     The project can walk students through how the interpreter works and then how to add features to the language.

     It can start as a simple little imperative programming language and then we can add things like recursive functions and types and things like that by the end of it.

     We could even potentially have a little compiler to JavaScript at the end of the chapter.
**** Walkthrough project: Ray tracing program
**** Abstract data types
***** Deciding upon the interface first
***** Hiding the data representation
*** Experience from teaching basic classes
**** What's the difference between languages?
     The more I've been teaching classes the more I've come to the conclusion that really newbie programmers don't really have a good sense for /what/ the difference between programming languages are. It's something that hadn't really occurred to me before, to be honest, but it's a serious issue for programmers. People who are first learning programming just have a vague conception that programming languages are things that are used to make computers work. Folks don't even seem to have a good sense of what their purpose is nor the fact that there's a deep underlying theoretical structure to programming languages and programming itself as a process.

     So, to that end I think we need to spend early time in the book just explaining what /code/ is, the fact that code /runs/, and then the fact that people are the ones who create these languages and decide these rules. Heck, even the idea that there needs to be a consistent grammar within a language is foreign to people who are absolute total beginners, the idea /of/ syntax just doesn't make any sense. That's a thing I need to remember as I'm going forward. 

     For example, when I've even just explained things like HTML, people who aren't used to programming ask questions like "what do the angle brackets *mean*?" or "what if I used a different kind of bracket?" or "does indentation matter?"

     Questions like that reveal that the fundamental problem with bootstrapping into being able to write code is with understand that programming languages a) have rules and that b) these rule are arbitrary inventions of the language designer. It diesn't even occur to me that that's a thing that needs to be learned most of the time, but then when I think back to circa 2002 and I found programming just so weird because I felt like I didn't even know how to get started. It all felt way too mystical and strange. It might have hurt that my first book was Stroustrop's book on C++ which is a little idiosyncratic IIRC. 

     Even by the time I was learning Ruby I think was having a lot of difficulty with these basic concepts of the /how/ and /why/ of syntax. This reinforces the fundamental message of this book which is to teach /computation/ rather than /programming/. That might sound really pretentious, but I think that's the fundamental goal. 
**** Big or small examples?
     This was an issue from a class I was teaching where there was a gentleman who was bothered by examples where they were /too large/ and he was being asked to type in a huge chunk of code without a clear idea of which parts matter and do what. 

     To me that really smacks of bad book design, but I think the issue here is that you need to have both small and complete code segments for reading. You can do something like the minix book, the one that included the FULL source code in the back while only including small amounts of code where it was necessary within the body of the text. I think I should probably do something like that, where I go ahead and have end-of-chapter and end-of-book sections that show /all/ the code including all the boiler plate while trying to keep the code as simple and literate as possible within the body of the text. 
** Which JavaScript?
   One thing I should probably consider is that ES2015 is getting more and more common all the time. Is there really a reason to keep teaching basic JavaScript?

   Well, at the moment the argument is that while it /will/ be used in the future it's not currently supported in all browsers. 

   Okay, but counterpoint: it /is/ supported in Node now, which is definitely a big deal. Maybe I could start with the most basic of JavaScript features and eventually move on to the ES2015 extensions? 

   For example, I don't /really/ want to talk about classes because I like prototypes just fine. 

   So in terms of arguments for and against I think I'm starting to convince myself that we should probably talk about this in terms of ES2015 though not necessarily any of the proposals that are newer than that. Why? Because I really don't think anything else is likely to be completely adopted in a convenient way for this audience, meanwhile it's not actually going to be that long before ES2015 is actually just standard and things like Babel aren't going to be needed anymore, y'know? 

   So what I think we should do for this is include base JavaScript whenever possible and then have perhaps inserts and other segments for explaining things like the new class system and arrow functions (also, gracious, it's really awkward to have the phrase arrows like this because I associate that with haskell arrows). 

   Now I don't think there's any point to showing things like JSX. That's pretty specific to a framework and isn't really useful for general computation. 
* New text
** Introduction
** The Goals of This Book
   The fundamental goal of this book is to teach the basic ideas of programming and computation in a way that's both mathematically rigorous and still understandable to anyone who's had even a single term of algebra. 

   My goal in /writing/ this book is to try and demystify the process of programming. I basically want to write the book I had wished I'd had more than a decade ago when I was first learning to write code. Back then, I was working on my master's degree in physics and I needed to modify some programs for a simulation we were running. I read some online tutorials for C++ and Fortran, the two languages we used, and managed to eventually lurch my way to my first working code. Even though I ended up writing working programs, I still didn't understand /why/ the lines of code needed to look the way they did or why all the previous attempts I'd muddled through /didn't/ work. I had no way of predicting what a program was going to do until I ran it.

   It wasn't until a number of years later, as I started teaching myself other programming languages such as Common Lisp and Haskell, that I began to understand the fundamentally mathematical nature of programs. I learned that programs /have/ rules and they're not (entirely) arbitrary. I learned that I could predict what a program was going to do even before I ran it. I figured out how to evaluate pieces of code with pen and paper before even typing anything. Finally, I discovered that not only are there rules behind every programming language, but there are in fact meta-principles that govern most programming languages and how to learn them. There are underlying principles behind /computation/ and different styles of programming languages merely take different perspectives on how to describe those underlying computations.

   To this end, I take a mostly neutral stance on choice of programming languages and styles of programming. I don't believe that there's a "best language" for everyone, but I do think any given person or team may find that a particular language is best for the way they think and the way they conceive of computation. 

   On the other hand, we have to pick a particular language in order to write this book and to that end I've chosen the Javascript programming language. Why JavaScript? Because at the end of the day JavaScript is a very flexible, popular, language that is able to adapt itself to many different styles of programming. It doesn't force you to write your code in /only one way/. 

Ultimately it is my hope that after reading this book it should be relatively simple task to learn any language you want and know how to write the programs you want to write in it.
** Outline of The Book
   Part 1 of the book proper is going to be centered on the basic built in operations and kinds of data that exist in Javascript and the /structure/ of programs themselves. We'll be covering
  + basic operations on numbers
  + how to makes choices
  + how to define functions
  + reading input into a program
  + printing output from a program
  + how to repeat actions
  + how to use objects to store data
  + how to encapsulate data using functions and scope

Part 2 of the book will be more advanced topics including:
  + advanced use of closures
  + prototypes, inheritance, and object oriented programming
  + the use of data structures such as dequeues, graphs, and heaps

Part 3 of the book will be a sequence of programming projects that will help connect all of the main topics together.
** What is Computation?
   Before we start learning about how to make computers do things, we should first talk about what computers /can/ do.

   That may sound like an odd question at first. I know that when I was first learning to code it never even occurred to me that there were things a computer *couldn't* do!

   There are limits to computation and they're pretty strange and profound. I hope I can convey even a fraction of the fascination these questions inspire in me. 
*** Computation in everyday life
   First off, the things can do are what we'll call /computation/. Computation has a real meaning beyond the actual computers and electronic devices we use. 

   Have you ever used a recipe to cook? Followed a friend's directions to get to their place?

   Can you remember learning to add the first time with a pencil & paper? You may have written down something like this:

   (insert latex code)

   You would add these numbers one by one, starting from the righthand side and moving to the left. This process isn't particularly any different than knitting patterns, recipes, or directions to get somewhere. They're all examples of algorithms. 

   Algorithms are processes for /doing/ something. I want to be clear on a distinction here. The /concept/ of addition of two numbers isn't an algorithm and isn't computation. There is, however, a *way* to compute. 
*** The limits of computation: part I
*** Real life examples
*** The heart of computation
    We've established that computation is something that exists in the universe itself, not just in computers. One way we can connect what computers do to the physical nature of computation is with /3D printers/. 3D printers, if you haven't gotten to see how one works, are devices that create three-dimensional shapes from specialized programs that describe how to perform the construction. 
    
    Many 3D printers use a moveable "head" that can extrude a hot plastic. The 3D object is built layer-by-layer putting down new hot plastic on top of already solidified plastic to build up the shape. A fundamental question to ask is: what are the limits of 3D printers? Are there things they can't make?

    The answer to that question is simple and interesting: anything that can be described with a program can be made with a 3D printer. 
** Getting Started in JavaScript
*** Loading code in the browser
*** Downloading node
*** Running code in node
** Learning a language
*** Programming languages are different
    
*** Why learning programming is hard
    As we get into the real meat of writing code, there'll probably be a number of frustrating moments. This is perfectly natural! 

    Programming isn't easy. It's actually pretty hard to learn at first. Why? Because programming requires you to be /precise/ in ways that we never are otherwise. When we talk to each other we can express ideas without having to explain every little detail. 
*** The common features of every programming language
    We talked before about the /heart of computation/. These were the kinds of things building blocks for every recipe, every set of directions, and every *program* that will ever exist. 

    While programming languages may differ in many respects, they'll always have some way of expressing these basic tasks. So, for example, there's always going to be a way to do something /repeatedly/. There's always going to be a way to form some kind of "loop" that will be able to run potentially forever. There will always be a way of storing information for later. 

    Different languages can express these things constructs different. There are languages where data can never be changed once stored. There's languages where programs are described by separate "actors" in the code sending each other messages. There's languages that are focused entirely on the concept of "functions", recipes that are 
** First Steps
 The /very/ first piece of syntax we're going to introduce in Javascript is how to print out values within a program. 

 Write the following lines of code in a file called ~FirstSteps.js~.
 #+BEGIN_SRC js :exports code :results output :tangle FirstSteps.js
   console.log(10);
   console.log(100);
   console.log(300);
 #+END_SRC

 #+RESULTS:
 : 10
 : 100
 : 300

If you run this file using the following command you should see the output indicated.
#+BEGIN_SRC sh :exports both :results output
  node FirstSteps.js
#+END_SRC

#+RESULTS:
: 10
: 100
: 300

We need to discuss what's happened here. First off, we've introduced the syntax ~console.log(v)~, whose semantics is to print out to the console the value of its argument, this means that it prints out the result of Javascript evaluating ~v~ and not just the literal syntax of ~v~ as we'll see shortly. This will be very useful for us in testing out our programs and checking that we understand the semantics of our constructs.

The second piece of syntax we've implicitly introduced is the /semi-colon/ and the /line break/. Javascript separates its syntax into /statements/ and /expressions/. We'll make more clear what the distinction between these two, but at first let's just say that statements are things that are separated by lines and expressions are things that can be fed as arguments. So, for example, ~10~ and ~console.log(10)~ are expressions but ~console.log(10);~ is a statement. For readability it's best to put statements on new lines, even though technically you could have written the above code as 

#+BEGIN_SRC js :exports code :results output 
  console.log(10);console.log(100);console.log(300);
#+END_SRC

but this isn't recommended as it makes code much harder to read.[fn:4]

Some other languages that use semicolons are Java, C, C++, C#, and PHP. The use of semicolons is one of those historic conventions that's good for the person writing the implementation of the programming language, but less so for the programmers who need to work in that language. Going back to our analogy about recipes, think of an expression as a thing like "a cup of flour" or "six onions" but a /statement/ is a step in the recipe such as "sautee six onions until soft". So in the example above each line that has ~console.log(v);~ in it is a separate statement that is executed in order, just like you'd execute the steps of a recipe in order. 

Now that we have a way to print out values and are starting to understand the difference between expressions and statements, we can start introducing operations on numbers as a first step. We have in JavaScript all the basic operations you're familiar with, including +,*, and -. We can see how they work in the following code, which you can copy into a file called ArithmeticExpressions.js

#+BEGIN_SRC js :exports code :results output  :tangle ArithmeticExpressions.js
  console.log(10 + 10);
  console.log(10 * 10);
  console.log(10 - 10);
  console.log(10 / 10);
#+END_SRC

#+RESULTS:
: 20
: 100
: 0
: 1

If you run this code with the following snippet then you should see the same results as below.

#+BEGIN_SRC sh :exports both :results output
  node ArithmeticExpressions.js
#+END_SRC

#+RESULTS:
: 20
: 100
: 0
: 1

It's important to note that the number that's printed out is the /result/ of the expression that's passed into the ~console.log~. 
*** Evaluating Code By Hand
    One of the themes of this book is going to be how to take a pen and paper and evaluate your code. This might seem like an odd skill to learn, but it's useful for getting rid of some of the "magic" feeling that comes with writing code for the first time. If you're not sure how a piece of code works, it's really helpful to be able to sit down and go through it step-by-step for yourself. 

So far, we've seen three pieces of syntax: 
    1. the ability to print using ~console.log~
    2. numbers represented using the normal decimal representation
    3. basic arithmetic operations on numbers
and two classes of syntax
    1. expressions
    2. statements

First, as we've aluded there's a notion of *values*. What makes an expression an expression is that it returns a *value* when evaluated. Statements, on the other hand, are useful for their control flow. When we coerce an expression into being a statement via ~expression;~ what we are doing is inherently throwing away the value returned by the expression. This is useful for things like ~console.log~ where we're not actually returning anything particularly useful and just using the /side effects/ of the expression. Side effects are all the ways an expression can affect the world other than through the value they return. So far the only side-effect we've seen is the ability to print output. We'll point out other side-effects as we're introduced to them.

Now, we take the pieces of syntax we've seen so far in order:
  1. ~console.log(e)~ is evaluated by first evaluating ~e~ until it yields a value ~v~ and then writing that value down under a column labeled "Output" on your paper
  2. numbers are evaluated simply: a number ~n~ written in decimal notation evaluates to itself, i.e. numbers are already values
  3. basic arithmetic operations are evaluated as the normal arithmetic rules you've learned, i.e. ~+~ is addition, ~-~ is substraction etc.
** The basics of JavaScript
*** Numbers
     We see numbers all the time, so they are probably the most familiar datatype you'll see in any programming language. 

     In JavaScript, numbers are written exactly like they normally are in mathematics: =1=, =10=, =-5000=, =3.14= etc. If you have any experience with other programming languages such as C or Java, it's notable that there's only /one/ form of number in JavaScript and not separate kinds of numbers for whole numbers or fractional numbers. 

     You can perform most of the operations on numbers you may have seen: =+=, =-=, =*=, and =/=. These all behave like you'd expect =+= is addition, =-= is subtraction, =*= is multiplication, and =/= is division. There's even the =%= operator which you may not have seen before. We call =%= the /remainder/ operation which, for =a%b=, returns the number left after you subtract =b= from =a= as many times as you can without going negative. Examples are in order. For =5 % 2= you can subtract =2= /twice/ from =5= which leaves =1= as a remainder. Similarly for =14 % 4= then =4= only goes into =14= three times, leaving =2= as a remainder. 

     There are, however, two special kinds of numbers in JavaScript: =Infinity= and =NaN=. Why does JavaScript have them though? Start running node or open the console in your browser and type the following expression: =1 / 0=.

     Most programming languages will throw an error or even *crash* when you divide by 0, but in JavaScript you instead get a result of =Infinity=. You can even use =Infinity= like it /was/ a number. Try typing the following expressions in your console:

     + =Infinity * Infinity=
     + =Infinity + 0=
     + =Infinity - Infinity=

What happened with that last one? You got the other odd number =NaN= which stands for "not a number". =NaN= is used in JavaScript to mean that the result was technically a /number/ but it doesn't have a well-defined value. Doing something like =Infinity - Infinity= doesn't have a well defined mathematical value. Neither does =Infinity * 0= or =Infinity / Infinity=. 

=NaN= shows up in more cases than just doing math with =Infinity=, though. =NaN= is returned whenever you are attempting arithmetic operations on something that doesn't make sense like, say, multiplying a string by a number. For example, try typing =3 * "3"= into the console. Once you have =NaN= there's no way to get back to the world of simple numbers. You can try something like =NaN * 0= or =NaN + Infinity= but the answer will *always* be =NaN=.

Finally, all arithmetic operations work by the normal presedence rules: expressions in parentheses are evaluated before multiplications which are evaluated before division which are evaluated before remainders which are evaluated before addition which are evaluated before subtraction.

A short visual way to look at it is =() > * > / > % > + > -=. So, for example, if you see the JavaScript expression =10 * 11 % 10= will this evaluate like =(10 * 11) % 10=, which is equal to 0, or like =10 * (11 % 10)= which is equal to 1? Since multiplication beats calculating the remainder, then this means we should first turn =10 * 11 % 10= into =110 % 10= and then finish the remainder, leaving us with =0=. If we're dealing with multiple expressions, such as =10 / 3 / 2= the expressions are evaluated in pieces from left-to-right: ~10 / 3 / 2 = 3.3333333 / 2 = 1.6666667~

**** Exercises
***** Exercise 1
    Look at the following arithmetic expressions and calculate the result without typing them into the console, then check your answers afterward:

    1. =10 / 3 - 3=
    2. =10 / (3 - 3)=
    3. =5 % 4 % 3=
    4. =1 / 0 / 0=
    5. =Infinity + NaN=
***** Exercise 2
     Try to imagine three different situations where you might encounter =Infinity= or =NaN= and they should be handled if detected.


*** Strings
     Even though it's fairly transparent, words themselves are a kind of data we constantly deal with: our texts, our emails, our social media posts are all text-as-data that our computers interact with.
     
     Given that our programs are also /text/, we need some way to distinguish between text-as-data and text-as-instructions for the computer. Text-as-data are called /strings/. We denote strings with quotation marks, either "like this" or 'possibly like this'. This mimics what we do in English all the time: there's a difference between this sentence and "this sentence". It's like the old playground joke "Say 'Mississippi five times fast'" to which you're supposed to respond "Mississippi five times fast". In fact, Javascript allows us to do exactly that. If we want to include quotation marks within a string we can either "do something 'like this'" or 'maybe something "like this"'.

*** Sequencing code
    Obviously if you could only run a single step of code in a program, you'd barely have a program at all.

    Think back to informal descriptions and our discussion of algorithms. When you're describing directions you often use
    + bullet
    + points
    + like
    + these
or  
    1. maybe
    2. numbered
    3. steps
Sometimes you just separate the steps in a description by having each step be its own sentence! No matter what, though, there's some way to distinguish steps as they're supposed to go in order. 
*** Variables
    One of the things that most programming languages give you to use is some way to /store/ data. These are called /variables/ in JavaScript and essentially every other language. 
**** Undefined
     We've skirted around one bit of weirdness until now: what happens if you attempt to use a variable that you haven't assigned a value to?

     Let's try this quickly and type the following lines in your console:

#+BEGIN_EXAMPLE
var x
x
#+END_EXAMPLE

     Surprisingly, there /is/ a value in the variable, =undefined=: a very special value that represents "there's no value here".

     =undefined= is like a number or string in that it /evaluates to itself/ and has no other special rules.

** Control flow
*** Making choices
**** Booleans
    Until now, all we've seen are operations akin to what you'd see on a calculator. Whether strings or numbers, we're merely performing simple operations on data and returning the result: adding numbers, concatenating strings. 

    Real programs do much more complicated things that involve choices or repetition. Think about logging into a computer and having it check your password. This involves making a comparison, is the password entered the same as the password expected, and then making a /decision/ about whether to let you use the computer. 

    The important pieces there are that the program needs to determine whether something is /true/ and then do one thing if it's true and another thing if it's not.

    To do these things we need to introduce the concept of /booleans/. There are *two* boolean values: =true= and =false=. We also have comparison operators that test for things such as "is this number bigger than that number" or "are these two things equal". 

    Below we have our table of boolean operations
    (insert table here)

    With these very /simple/ operations in hand, how do we make /decisions/? The most basic way to make a choice in programming is to use the /if statement/.

    The most basic if-statements in JavaScript have the following shape

**** If statements
***** Real life examples and analogues
      If statements are represented by our notion of decisions in our directions. The keywords to look out for are /if/ or /when/. Whenever your informal description includes /if/ or /when/ or /then/ or /else/, you're going to have some kind of if-statement in your code. 

*** Repetition
**** Definite vs. indefinite
     The ability to repeat actions is something we named as a key concept in computation. 
**** For loops
**** 
